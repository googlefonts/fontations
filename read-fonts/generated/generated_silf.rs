// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct SilfMarker {
    compiler_version_byte_start: Option<usize>,
    _padding_byte_start: Option<usize>,
}

impl SilfMarker {
    pub fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + MajorMinor::RAW_BYTE_LEN
    }

    pub fn compiler_version_byte_range(&self) -> Option<Range<usize>> {
        let start = self.compiler_version_byte_start?;
        Some(start..start + MajorMinor::RAW_BYTE_LEN)
    }

    pub fn sub_tables_byte_range(&self) -> Range<usize> {
        let start = self
            .compiler_version_byte_range()
            .map(|range| range.end)
            .unwrap_or_else(|| self.version_byte_range().end);
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn _padding_byte_range(&self) -> Option<Range<usize>> {
        let start = self._padding_byte_start?;
        Some(start..start + u16::RAW_BYTE_LEN)
    }

    pub fn start_offset_byte_range(&self) -> Range<usize> {
        let start = self
            ._padding_byte_range()
            .map(|range| range.end)
            .unwrap_or_else(|| self.sub_tables_byte_range().end);
        start..start + Offset32::RAW_BYTE_LEN
    }
}

impl MinByteRange for SilfMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.start_offset_byte_range().end
    }
}

impl TopLevelTable for Silf<'_> {
    /// `Silf`
    const TAG: Tag = Tag::new(b"Silf");
}

impl<'a> FontRead<'a> for Silf<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let version: MajorMinor = cursor.read()?;
        let compiler_version_byte_start = version
            .compatible(3u16)
            .then(|| cursor.position())
            .transpose()?;
        version
            .compatible(3u16)
            .then(|| cursor.advance::<MajorMinor>());
        cursor.advance::<u16>();
        let _padding_byte_start = version
            .compatible(2u16)
            .then(|| cursor.position())
            .transpose()?;
        version.compatible(2u16).then(|| cursor.advance::<u16>());
        cursor.advance::<Offset32>();
        cursor.finish(SilfMarker {
            compiler_version_byte_start,
            _padding_byte_start,
        })
    }
}

pub type Silf<'a> = TableRef<'a, SilfMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> Silf<'a> {
    /// (major, minor) Version for the Silf table
    pub fn version(&self) -> MajorMinor {
        let range = self.shape.version_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn compiler_version(&self) -> Option<MajorMinor> {
        let range = self.shape.compiler_version_byte_range()?;
        Some(self.data.read_at(range.start).unwrap())
    }

    pub fn sub_tables(&self) -> u16 {
        let range = self.shape.sub_tables_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    pub fn start_offset(&self) -> Offset32 {
        let range = self.shape.start_offset_byte_range();
        self.data.read_at(range.start).unwrap()
    }

    /// Attempt to resolve [`start_offset`][Self::start_offset].
    pub fn start(&self) -> Result<SilfSubtable<'a>, ReadError> {
        let data = self.data;
        self.start_offset().resolve(data)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for Silf<'a> {
    fn type_name(&self) -> &str {
        "Silf"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        let version = self.version();
        match idx {
            0usize => Some(Field::new("version", self.version())),
            1usize if version.compatible(3u16) => Some(Field::new(
                "compiler_version",
                self.compiler_version().unwrap(),
            )),
            2usize => Some(Field::new("sub_tables", self.sub_tables())),
            3usize => Some(Field::new(
                "start_offset",
                FieldType::offset(self.start_offset(), self.start()),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for Silf<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct SilfSubtableMarker {}

impl SilfSubtableMarker {}

impl<'a> FontRead<'a> for SilfSubtable<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let cursor = data.cursor();
        cursor.finish(SilfSubtableMarker {})
    }
}

pub type SilfSubtable<'a> = TableRef<'a, SilfSubtableMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> SilfSubtable<'a> {}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for SilfSubtable<'a> {
    fn type_name(&self) -> &str {
        "SilfSubtable"
    }

    #[allow(unused_variables)]
    #[allow(clippy::match_single_binding)]
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for SilfSubtable<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}
