// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

/// The [VVAR (Vertical Metrics Variations)](https://docs.microsoft.com/en-us/typography/opentype/spec/vvar) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct VvarMarker {}

impl<'a> MinByteRange for Vvar<'a> {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.v_org_mapping_offset_byte_range().end
    }
}

impl TopLevelTable for Vvar<'_> {
    /// `VVAR`
    const TAG: Tag = Tag::new(b"VVAR");
}

impl<'a> FontRead<'a> for Vvar<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        if data.len() < Self::MIN_SIZE {
            return Err(ReadError::OutOfBounds);
        }
        Ok(Self {
            data,
            shape: VvarMarker {},
        })
    }
}

impl ReadArgs for Vvar<'_> {
    type Args = ();
}

impl<'a> FontReadWithArgs<'a> for Vvar<'a> {
    fn read_with_args(data: FontData<'a>, _: &Self::Args) -> Result<Self, ReadError> {
        Self::read(data)
    }
}

/// The [VVAR (Vertical Metrics Variations)](https://docs.microsoft.com/en-us/typography/opentype/spec/vvar) table
pub type Vvar<'a> = TableRef<'a, VvarMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> Vvar<'a> {
    pub const MIN_SIZE: usize = (MajorMinor::RAW_BYTE_LEN
        + Offset32::RAW_BYTE_LEN
        + Offset32::RAW_BYTE_LEN
        + Offset32::RAW_BYTE_LEN
        + Offset32::RAW_BYTE_LEN
        + Offset32::RAW_BYTE_LEN);

    pub fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        let end = start + MajorMinor::RAW_BYTE_LEN;
        start..end
    }

    pub fn item_variation_store_offset_byte_range(&self) -> Range<usize> {
        let start = self.version_byte_range().end;
        let end = start + Offset32::RAW_BYTE_LEN;
        start..end
    }

    pub fn advance_height_mapping_offset_byte_range(&self) -> Range<usize> {
        let start = self.item_variation_store_offset_byte_range().end;
        let end = start + Offset32::RAW_BYTE_LEN;
        start..end
    }

    pub fn tsb_mapping_offset_byte_range(&self) -> Range<usize> {
        let start = self.advance_height_mapping_offset_byte_range().end;
        let end = start + Offset32::RAW_BYTE_LEN;
        start..end
    }

    pub fn bsb_mapping_offset_byte_range(&self) -> Range<usize> {
        let start = self.tsb_mapping_offset_byte_range().end;
        let end = start + Offset32::RAW_BYTE_LEN;
        start..end
    }

    pub fn v_org_mapping_offset_byte_range(&self) -> Range<usize> {
        let start = self.bsb_mapping_offset_byte_range().end;
        let end = start + Offset32::RAW_BYTE_LEN;
        start..end
    }

    /// Major version number of the horizontal metrics variations table — set to 1.
    /// Minor version number of the horizontal metrics variations table — set to 0.
    pub fn version(&self) -> MajorMinor {
        let range = self.version_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// Offset in bytes from the start of this table to the item variation store table.
    pub fn item_variation_store_offset(&self) -> Offset32 {
        let range = self.item_variation_store_offset_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`item_variation_store_offset`][Self::item_variation_store_offset].
    pub fn item_variation_store(&self) -> Result<ItemVariationStore<'a>, ReadError> {
        let data = self.data;
        self.item_variation_store_offset()
            .resolve_with_args(data, &())
    }

    /// Offset in bytes from the start of this table to the delta-set index mapping for advance heights (may be NULL).
    pub fn advance_height_mapping_offset(&self) -> Nullable<Offset32> {
        let range = self.advance_height_mapping_offset_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`advance_height_mapping_offset`][Self::advance_height_mapping_offset].
    pub fn advance_height_mapping(&self) -> Option<Result<DeltaSetIndexMap<'a>, ReadError>> {
        let data = self.data;
        self.advance_height_mapping_offset()
            .resolve_with_args(data, &())
    }

    /// Offset in bytes from the start of this table to the delta-set index mapping for top side bearings (may be NULL).
    pub fn tsb_mapping_offset(&self) -> Nullable<Offset32> {
        let range = self.tsb_mapping_offset_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`tsb_mapping_offset`][Self::tsb_mapping_offset].
    pub fn tsb_mapping(&self) -> Option<Result<DeltaSetIndexMap<'a>, ReadError>> {
        let data = self.data;
        self.tsb_mapping_offset().resolve_with_args(data, &())
    }

    /// Offset in bytes from the start of this table to the delta-set index mapping for bottom side bearings (may be NULL).
    pub fn bsb_mapping_offset(&self) -> Nullable<Offset32> {
        let range = self.bsb_mapping_offset_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`bsb_mapping_offset`][Self::bsb_mapping_offset].
    pub fn bsb_mapping(&self) -> Option<Result<DeltaSetIndexMap<'a>, ReadError>> {
        let data = self.data;
        self.bsb_mapping_offset().resolve_with_args(data, &())
    }

    /// Offset in bytes from the start of this table to the delta-set index mapping for Y coordinates of vertical origins (may be NULL).
    pub fn v_org_mapping_offset(&self) -> Nullable<Offset32> {
        let range = self.v_org_mapping_offset_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`v_org_mapping_offset`][Self::v_org_mapping_offset].
    pub fn v_org_mapping(&self) -> Option<Result<DeltaSetIndexMap<'a>, ReadError>> {
        let data = self.data;
        self.v_org_mapping_offset().resolve_with_args(data, &())
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for Vvar<'a> {
    fn type_name(&self) -> &str {
        "Vvar"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("version", self.version())),
            1usize => Some(Field::new(
                "item_variation_store_offset",
                FieldType::offset(
                    self.item_variation_store_offset(),
                    self.item_variation_store(),
                ),
            )),
            2usize => Some(Field::new(
                "advance_height_mapping_offset",
                FieldType::offset(
                    self.advance_height_mapping_offset(),
                    self.advance_height_mapping(),
                ),
            )),
            3usize => Some(Field::new(
                "tsb_mapping_offset",
                FieldType::offset(self.tsb_mapping_offset(), self.tsb_mapping()),
            )),
            4usize => Some(Field::new(
                "bsb_mapping_offset",
                FieldType::offset(self.bsb_mapping_offset(), self.bsb_mapping()),
            )),
            5usize => Some(Field::new(
                "v_org_mapping_offset",
                FieldType::offset(self.v_org_mapping_offset(), self.v_org_mapping()),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for Vvar<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}
