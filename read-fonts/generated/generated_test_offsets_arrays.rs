// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct KindsOfOffsetsMarker {}

impl<'a> MinByteRange for KindsOfOffsets<'a> {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.record_array_offset_byte_range().end
    }
}

impl<'a> FontRead<'a> for KindsOfOffsets<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        if data.len() < Self::MIN_SIZE {
            return Err(ReadError::OutOfBounds);
        }
        Ok(Self {
            data,
            shape: KindsOfOffsetsMarker {},
        })
    }
}

impl ReadArgs for KindsOfOffsets<'_> {
    type Args = ();
}

impl<'a> FontReadWithArgs<'a> for KindsOfOffsets<'a> {
    fn read_with_args(data: FontData<'a>, _: &Self::Args) -> Result<Self, ReadError> {
        Self::read(data)
    }
}

impl<'a> Sanitize<'a> for KindsOfOffsets<'a> {
    #[allow(unused_variables)]
    fn sanitize_impl(&self) -> Result<(), ReadError> {
        let offset_data = self.offset_data();
        self.nonnullable()?.sanitize_impl()?;
        if let Some(thing) = self.nullable() {
            thing?.sanitize_impl()?;
        };
        if let Some(thing) = self.versioned_nonnullable() {
            thing?.sanitize_impl()?;
        };
        if let Some(thing) = self.versioned_nullable() {
            thing?.sanitize_impl()?;
        };
        Ok(())
    }
}

impl<'a> Sanitized<KindsOfOffsets<'a>> {
    /// The major/minor version of the GDEF table
    pub fn version(&self) -> MajorMinor {
        let range = self.0.version_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }

    /// A normal offset
    pub fn nonnullable_offset(&self) -> Offset16 {
        let range = self.0.nonnullable_offset_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`nonnullable_offset`][Self::nonnullable_offset].
    pub fn nonnullable(&self) -> Result<Sanitized<Dummy<'a>>, ReadError> {
        let data = self.0.data;
        self.nonnullable_offset().resolve_with_args(data, &())
    }

    /// An offset that is nullable, but always present
    pub fn nullable_offset(&self) -> Nullable<Offset16> {
        let range = self.0.nullable_offset_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`nullable_offset`][Self::nullable_offset].
    pub fn nullable(&self) -> Option<Result<Sanitized<Dummy<'a>>, ReadError>> {
        let data = self.0.data;
        self.nullable_offset().resolve_with_args(data, &())
    }

    /// count of the array at array_offset
    pub fn array_offset_count(&self) -> u16 {
        let range = self.0.array_offset_count_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }

    /// An offset to an array:
    pub fn array_offset(&self) -> Offset16 {
        let range = self.0.array_offset_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`array_offset`][Self::array_offset].
    pub fn array(&self) -> Result<&'a [BigEndian<u16>], ReadError> {
        let data = self.0.data;
        let args = self.array_offset_count();
        self.array_offset().resolve_with_args(data, &args)
    }

    /// An offset to an array of records
    pub fn record_array_offset(&self) -> Offset16 {
        let range = self.0.record_array_offset_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`record_array_offset`][Self::record_array_offset].
    pub fn record_array(&self) -> Result<&'a [Sanitized<Shmecord>], ReadError> {
        let data = self.0.data;
        let args = self.array_offset_count();
        self.record_array_offset().resolve_with_args(data, &args)
    }

    /// A nullable, versioned offset to an array of records
    pub fn versioned_nullable_record_array_offset(&self) -> Option<Nullable<Offset16>> {
        let range = self.0.versioned_nullable_record_array_offset_byte_range();
        Some(unsafe { self.0.data.read_at_unchecked(range.start) })
    }

    /// Attempt to resolve [`versioned_nullable_record_array_offset`][Self::versioned_nullable_record_array_offset].
    pub fn versioned_nullable_record_array(
        &self,
    ) -> Option<Result<&'a [Sanitized<Shmecord>], ReadError>> {
        let data = self.0.data;
        let args = self.array_offset_count();
        self.versioned_nullable_record_array_offset()
            .map(|x| x.resolve_with_args(data, &args))?
    }

    /// A normal offset that is versioned
    pub fn versioned_nonnullable_offset(&self) -> Option<Offset16> {
        let range = self.0.versioned_nonnullable_offset_byte_range();
        Some(unsafe { self.0.data.read_at_unchecked(range.start) })
    }

    /// Attempt to resolve [`versioned_nonnullable_offset`][Self::versioned_nonnullable_offset].
    pub fn versioned_nonnullable(&self) -> Option<Result<Sanitized<Dummy<'a>>, ReadError>> {
        let data = self.0.data;
        self.versioned_nonnullable_offset()
            .map(|x| x.resolve_with_args(data, &()))
    }

    /// An offset that is nullable and versioned
    pub fn versioned_nullable_offset(&self) -> Option<Nullable<Offset32>> {
        let range = self.0.versioned_nullable_offset_byte_range();
        Some(unsafe { self.0.data.read_at_unchecked(range.start) })
    }

    /// Attempt to resolve [`versioned_nullable_offset`][Self::versioned_nullable_offset].
    pub fn versioned_nullable(&self) -> Option<Result<Sanitized<Dummy<'a>>, ReadError>> {
        let data = self.0.data;
        self.versioned_nullable_offset()
            .map(|x| x.resolve_with_args(data, &()))?
    }
}

pub type KindsOfOffsets<'a> = TableRef<'a, KindsOfOffsetsMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> KindsOfOffsets<'a> {
    pub const MIN_SIZE: usize = (MajorMinor::RAW_BYTE_LEN
        + Offset16::RAW_BYTE_LEN
        + Offset16::RAW_BYTE_LEN
        + u16::RAW_BYTE_LEN
        + Offset16::RAW_BYTE_LEN
        + Offset16::RAW_BYTE_LEN);

    pub fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        let end = start + MajorMinor::RAW_BYTE_LEN;
        start..end
    }

    pub fn nonnullable_offset_byte_range(&self) -> Range<usize> {
        let start = self.version_byte_range().end;
        let end = start + Offset16::RAW_BYTE_LEN;
        start..end
    }

    pub fn nullable_offset_byte_range(&self) -> Range<usize> {
        let start = self.nonnullable_offset_byte_range().end;
        let end = start + Offset16::RAW_BYTE_LEN;
        start..end
    }

    pub fn array_offset_count_byte_range(&self) -> Range<usize> {
        let start = self.nullable_offset_byte_range().end;
        let end = start + u16::RAW_BYTE_LEN;
        start..end
    }

    pub fn array_offset_byte_range(&self) -> Range<usize> {
        let start = self.array_offset_count_byte_range().end;
        let end = start + Offset16::RAW_BYTE_LEN;
        start..end
    }

    pub fn record_array_offset_byte_range(&self) -> Range<usize> {
        let start = self.array_offset_byte_range().end;
        let end = start + Offset16::RAW_BYTE_LEN;
        start..end
    }

    pub fn versioned_nullable_record_array_offset_byte_range(&self) -> Range<usize> {
        let start = self.record_array_offset_byte_range().end;
        let end = (self.version().compatible((1u16, 1u16)))
            .then(|| start + Offset16::RAW_BYTE_LEN)
            .unwrap_or(start);
        start..end
    }

    pub fn versioned_nonnullable_offset_byte_range(&self) -> Range<usize> {
        let start = self.versioned_nullable_record_array_offset_byte_range().end;
        let end = (self.version().compatible((1u16, 1u16)))
            .then(|| start + Offset16::RAW_BYTE_LEN)
            .unwrap_or(start);
        start..end
    }

    pub fn versioned_nullable_offset_byte_range(&self) -> Range<usize> {
        let start = self.versioned_nonnullable_offset_byte_range().end;
        let end = (self.version().compatible((1u16, 1u16)))
            .then(|| start + Offset32::RAW_BYTE_LEN)
            .unwrap_or(start);
        start..end
    }

    /// The major/minor version of the GDEF table
    pub fn version(&self) -> MajorMinor {
        let range = self.version_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// A normal offset
    pub fn nonnullable_offset(&self) -> Offset16 {
        let range = self.nonnullable_offset_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`nonnullable_offset`][Self::nonnullable_offset].
    pub fn nonnullable(&self) -> Result<Dummy<'a>, ReadError> {
        let data = self.data;
        self.nonnullable_offset().resolve_with_args(data, &())
    }

    /// An offset that is nullable, but always present
    pub fn nullable_offset(&self) -> Nullable<Offset16> {
        let range = self.nullable_offset_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`nullable_offset`][Self::nullable_offset].
    pub fn nullable(&self) -> Option<Result<Dummy<'a>, ReadError>> {
        let data = self.data;
        self.nullable_offset().resolve_with_args(data, &())
    }

    /// count of the array at array_offset
    pub fn array_offset_count(&self) -> u16 {
        let range = self.array_offset_count_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// An offset to an array:
    pub fn array_offset(&self) -> Offset16 {
        let range = self.array_offset_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`array_offset`][Self::array_offset].
    pub fn array(&self) -> Result<&'a [BigEndian<u16>], ReadError> {
        let data = self.data;
        let args = self.array_offset_count();
        self.array_offset().resolve_with_args(data, &args)
    }

    /// An offset to an array of records
    pub fn record_array_offset(&self) -> Offset16 {
        let range = self.record_array_offset_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// Attempt to resolve [`record_array_offset`][Self::record_array_offset].
    pub fn record_array(&self) -> Result<&'a [Shmecord], ReadError> {
        let data = self.data;
        let args = self.array_offset_count();
        self.record_array_offset().resolve_with_args(data, &args)
    }

    /// A nullable, versioned offset to an array of records
    pub fn versioned_nullable_record_array_offset(&self) -> Option<Nullable<Offset16>> {
        let range = self.versioned_nullable_record_array_offset_byte_range();
        (!range.is_empty()).then(|| unsafe { self.data.read_at_unchecked(range.start) })
    }

    /// Attempt to resolve [`versioned_nullable_record_array_offset`][Self::versioned_nullable_record_array_offset].
    pub fn versioned_nullable_record_array(&self) -> Option<Result<&'a [Shmecord], ReadError>> {
        let data = self.data;
        let args = self.array_offset_count();
        self.versioned_nullable_record_array_offset()
            .map(|x| x.resolve_with_args(data, &args))?
    }

    /// A normal offset that is versioned
    pub fn versioned_nonnullable_offset(&self) -> Option<Offset16> {
        let range = self.versioned_nonnullable_offset_byte_range();
        (!range.is_empty()).then(|| unsafe { self.data.read_at_unchecked(range.start) })
    }

    /// Attempt to resolve [`versioned_nonnullable_offset`][Self::versioned_nonnullable_offset].
    pub fn versioned_nonnullable(&self) -> Option<Result<Dummy<'a>, ReadError>> {
        let data = self.data;
        self.versioned_nonnullable_offset()
            .map(|x| x.resolve_with_args(data, &()))
    }

    /// An offset that is nullable and versioned
    pub fn versioned_nullable_offset(&self) -> Option<Nullable<Offset32>> {
        let range = self.versioned_nullable_offset_byte_range();
        (!range.is_empty()).then(|| unsafe { self.data.read_at_unchecked(range.start) })
    }

    /// Attempt to resolve [`versioned_nullable_offset`][Self::versioned_nullable_offset].
    pub fn versioned_nullable(&self) -> Option<Result<Dummy<'a>, ReadError>> {
        let data = self.data;
        self.versioned_nullable_offset()
            .map(|x| x.resolve_with_args(data, &()))?
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for KindsOfOffsets<'a> {
    fn type_name(&self) -> &str {
        "KindsOfOffsets"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("version", self.version())),
            1usize => Some(Field::new(
                "nonnullable_offset",
                FieldType::offset(self.nonnullable_offset(), self.nonnullable()),
            )),
            2usize => Some(Field::new(
                "nullable_offset",
                FieldType::offset(self.nullable_offset(), self.nullable()),
            )),
            3usize => Some(Field::new("array_offset_count", self.array_offset_count())),
            4usize => Some(Field::new(
                "array_offset",
                FieldType::offset_to_array_of_scalars(self.array_offset(), self.array()),
            )),
            5usize => Some(Field::new(
                "record_array_offset",
                traversal::FieldType::offset_to_array_of_records(
                    self.record_array_offset(),
                    self.record_array(),
                    stringify!(Shmecord),
                    self.offset_data(),
                ),
            )),
            6usize if self.version().compatible((1u16, 1u16)) => Some(Field::new(
                "versioned_nullable_record_array_offset",
                traversal::FieldType::offset_to_array_of_records(
                    self.versioned_nullable_record_array_offset().unwrap(),
                    self.versioned_nullable_record_array(),
                    stringify!(Shmecord),
                    self.offset_data(),
                ),
            )),
            7usize if self.version().compatible((1u16, 1u16)) => Some(Field::new(
                "versioned_nonnullable_offset",
                FieldType::offset(
                    self.versioned_nonnullable_offset().unwrap(),
                    self.versioned_nonnullable().unwrap(),
                ),
            )),
            8usize if self.version().compatible((1u16, 1u16)) => Some(Field::new(
                "versioned_nullable_offset",
                FieldType::offset(
                    self.versioned_nullable_offset().unwrap(),
                    self.versioned_nullable(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for KindsOfOffsets<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct KindsOfArraysOfOffsetsMarker {}

impl<'a> MinByteRange for KindsOfArraysOfOffsets<'a> {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.nullable_offsets_byte_range().end
    }
}

impl<'a> FontRead<'a> for KindsOfArraysOfOffsets<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        if data.len() < Self::MIN_SIZE {
            return Err(ReadError::OutOfBounds);
        }
        Ok(Self {
            data,
            shape: KindsOfArraysOfOffsetsMarker {},
        })
    }
}

impl ReadArgs for KindsOfArraysOfOffsets<'_> {
    type Args = ();
}

impl<'a> FontReadWithArgs<'a> for KindsOfArraysOfOffsets<'a> {
    fn read_with_args(data: FontData<'a>, _: &Self::Args) -> Result<Self, ReadError> {
        Self::read(data)
    }
}

impl<'a> Sanitize<'a> for KindsOfArraysOfOffsets<'a> {
    #[allow(unused_variables)]
    fn sanitize_impl(&self) -> Result<(), ReadError> {
        let offset_data = self.offset_data();
        self.nonnullables().sanitize_impl()?;
        self.nullables().sanitize_impl()?;
        if let Some(thing) = self.versioned_nonnullables() {
            thing.sanitize_impl()?;
        };
        if let Some(thing) = self.versioned_nullables() {
            thing.sanitize_impl()?;
        };
        Ok(())
    }
}

impl<'a> Sanitized<KindsOfArraysOfOffsets<'a>> {
    /// The version
    pub fn version(&self) -> MajorMinor {
        let range = self.0.version_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }

    /// The number of items in each array
    pub fn count(&self) -> u16 {
        let range = self.0.count_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }

    /// A normal array offset
    pub fn nonnullable_offsets(&self) -> &'a [BigEndian<Offset16>] {
        let range = self.0.nonnullable_offsets_byte_range();
        unsafe { self.0.data.read_array_unchecked(range) }
    }

    /// A dynamically resolving wrapper for [`nonnullable_offsets`][Self::nonnullable_offsets].
    pub fn nonnullables(&self) -> ArrayOfOffsets<'a, Sanitized<Dummy<'a>>, Offset16> {
        let data = self.0.data;
        let offsets = self.nonnullable_offsets();
        ArrayOfOffsets::new(offsets, data, ())
    }

    /// An offset that is nullable, but always present
    pub fn nullable_offsets(&self) -> &'a [BigEndian<Nullable<Offset16>>] {
        let range = self.0.nullable_offsets_byte_range();
        unsafe { self.0.data.read_array_unchecked(range) }
    }

    /// A dynamically resolving wrapper for [`nullable_offsets`][Self::nullable_offsets].
    pub fn nullables(&self) -> ArrayOfNullableOffsets<'a, Sanitized<Dummy<'a>>, Offset16> {
        let data = self.0.data;
        let offsets = self.nullable_offsets();
        ArrayOfNullableOffsets::new(offsets, data, ())
    }

    /// A normal offset that is versioned
    pub fn versioned_nonnullable_offsets(&self) -> Option<&'a [BigEndian<Offset16>]> {
        let range = self.0.versioned_nonnullable_offsets_byte_range();
        Some(unsafe { self.0.data.read_array_unchecked(range) })
    }

    /// A dynamically resolving wrapper for [`versioned_nonnullable_offsets`][Self::versioned_nonnullable_offsets].
    pub fn versioned_nonnullables(
        &self,
    ) -> Option<ArrayOfOffsets<'a, Sanitized<Dummy<'a>>, Offset16>> {
        let data = self.0.data;
        let offsets = self.versioned_nonnullable_offsets();
        offsets.map(|offsets| ArrayOfOffsets::new(offsets, data, ()))
    }

    /// An offset that is nullable and versioned
    pub fn versioned_nullable_offsets(&self) -> Option<&'a [BigEndian<Nullable<Offset16>>]> {
        let range = self.0.versioned_nullable_offsets_byte_range();
        Some(unsafe { self.0.data.read_array_unchecked(range) })
    }

    /// A dynamically resolving wrapper for [`versioned_nullable_offsets`][Self::versioned_nullable_offsets].
    pub fn versioned_nullables(
        &self,
    ) -> Option<ArrayOfNullableOffsets<'a, Sanitized<Dummy<'a>>, Offset16>> {
        let data = self.0.data;
        let offsets = self.versioned_nullable_offsets();
        offsets.map(|offsets| ArrayOfNullableOffsets::new(offsets, data, ()))
    }
}

pub type KindsOfArraysOfOffsets<'a> = TableRef<'a, KindsOfArraysOfOffsetsMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> KindsOfArraysOfOffsets<'a> {
    pub const MIN_SIZE: usize = (MajorMinor::RAW_BYTE_LEN + u16::RAW_BYTE_LEN);

    pub fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        let end = start + MajorMinor::RAW_BYTE_LEN;
        start..end
    }

    pub fn count_byte_range(&self) -> Range<usize> {
        let start = self.version_byte_range().end;
        let end = start + u16::RAW_BYTE_LEN;
        start..end
    }

    pub fn nonnullable_offsets_byte_range(&self) -> Range<usize> {
        let count = self.count();
        let start = self.count_byte_range().end;
        let end = start + (count as usize).saturating_mul(Offset16::RAW_BYTE_LEN);
        start..end
    }

    pub fn nullable_offsets_byte_range(&self) -> Range<usize> {
        let count = self.count();
        let start = self.nonnullable_offsets_byte_range().end;
        let end = start + (count as usize).saturating_mul(Offset16::RAW_BYTE_LEN);
        start..end
    }

    pub fn versioned_nonnullable_offsets_byte_range(&self) -> Range<usize> {
        let count = self.count();
        let start = self.nullable_offsets_byte_range().end;
        let end = (self.version().compatible((1u16, 1u16)))
            .then(|| start + (count as usize).saturating_mul(Offset16::RAW_BYTE_LEN))
            .unwrap_or(start);
        start..end
    }

    pub fn versioned_nullable_offsets_byte_range(&self) -> Range<usize> {
        let count = self.count();
        let start = self.versioned_nonnullable_offsets_byte_range().end;
        let end = (self.version().compatible((1u16, 1u16)))
            .then(|| start + (count as usize).saturating_mul(Offset16::RAW_BYTE_LEN))
            .unwrap_or(start);
        start..end
    }

    /// The version
    pub fn version(&self) -> MajorMinor {
        let range = self.version_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// The number of items in each array
    pub fn count(&self) -> u16 {
        let range = self.count_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// A normal array offset
    pub fn nonnullable_offsets(&self) -> &'a [BigEndian<Offset16>] {
        let range = self.nonnullable_offsets_byte_range();
        unsafe { self.data.read_array_unchecked(range) }
    }

    /// A dynamically resolving wrapper for [`nonnullable_offsets`][Self::nonnullable_offsets].
    pub fn nonnullables(&self) -> ArrayOfOffsets<'a, Dummy<'a>, Offset16> {
        let data = self.data;
        let offsets = self.nonnullable_offsets();
        ArrayOfOffsets::new(offsets, data, ())
    }

    /// An offset that is nullable, but always present
    pub fn nullable_offsets(&self) -> &'a [BigEndian<Nullable<Offset16>>] {
        let range = self.nullable_offsets_byte_range();
        unsafe { self.data.read_array_unchecked(range) }
    }

    /// A dynamically resolving wrapper for [`nullable_offsets`][Self::nullable_offsets].
    pub fn nullables(&self) -> ArrayOfNullableOffsets<'a, Dummy<'a>, Offset16> {
        let data = self.data;
        let offsets = self.nullable_offsets();
        ArrayOfNullableOffsets::new(offsets, data, ())
    }

    /// A normal offset that is versioned
    pub fn versioned_nonnullable_offsets(&self) -> Option<&'a [BigEndian<Offset16>]> {
        let range = self.versioned_nonnullable_offsets_byte_range();
        (!range.is_empty()).then(|| unsafe { self.data.read_array_unchecked(range) })
    }

    /// A dynamically resolving wrapper for [`versioned_nonnullable_offsets`][Self::versioned_nonnullable_offsets].
    pub fn versioned_nonnullables(&self) -> Option<ArrayOfOffsets<'a, Dummy<'a>, Offset16>> {
        let data = self.data;
        let offsets = self.versioned_nonnullable_offsets();
        offsets.map(|offsets| ArrayOfOffsets::new(offsets, data, ()))
    }

    /// An offset that is nullable and versioned
    pub fn versioned_nullable_offsets(&self) -> Option<&'a [BigEndian<Nullable<Offset16>>]> {
        let range = self.versioned_nullable_offsets_byte_range();
        (!range.is_empty()).then(|| unsafe { self.data.read_array_unchecked(range) })
    }

    /// A dynamically resolving wrapper for [`versioned_nullable_offsets`][Self::versioned_nullable_offsets].
    pub fn versioned_nullables(&self) -> Option<ArrayOfNullableOffsets<'a, Dummy<'a>, Offset16>> {
        let data = self.data;
        let offsets = self.versioned_nullable_offsets();
        offsets.map(|offsets| ArrayOfNullableOffsets::new(offsets, data, ()))
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for KindsOfArraysOfOffsets<'a> {
    fn type_name(&self) -> &str {
        "KindsOfArraysOfOffsets"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("version", self.version())),
            1usize => Some(Field::new("count", self.count())),
            2usize => Some({
                let data = self.data;
                Field::new(
                    "nonnullable_offsets",
                    FieldType::array_of_offsets(
                        better_type_name::<Dummy>(),
                        self.nonnullable_offsets(),
                        move |off| {
                            let target = off.get().resolve_with_args::<Dummy>(data, &());
                            FieldType::offset(off.get(), target)
                        },
                    ),
                )
            }),
            3usize => Some({
                let data = self.data;
                Field::new(
                    "nullable_offsets",
                    FieldType::array_of_offsets(
                        better_type_name::<Dummy>(),
                        self.nullable_offsets(),
                        move |off| {
                            let target = off.get().resolve_with_args::<Dummy>(data, &());
                            FieldType::offset(off.get(), target)
                        },
                    ),
                )
            }),
            4usize if self.version().compatible((1u16, 1u16)) => Some({
                let data = self.data;
                Field::new(
                    "versioned_nonnullable_offsets",
                    FieldType::array_of_offsets(
                        better_type_name::<Dummy>(),
                        self.versioned_nonnullable_offsets().unwrap(),
                        move |off| {
                            let target = off.get().resolve_with_args::<Dummy>(data, &());
                            FieldType::offset(off.get(), target)
                        },
                    ),
                )
            }),
            5usize if self.version().compatible((1u16, 1u16)) => Some({
                let data = self.data;
                Field::new(
                    "versioned_nullable_offsets",
                    FieldType::array_of_offsets(
                        better_type_name::<Dummy>(),
                        self.versioned_nullable_offsets().unwrap(),
                        move |off| {
                            let target = off.get().resolve_with_args::<Dummy>(data, &());
                            FieldType::offset(off.get(), target)
                        },
                    ),
                )
            }),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for KindsOfArraysOfOffsets<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct KindsOfArraysMarker {}

impl<'a> MinByteRange for KindsOfArrays<'a> {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.records_byte_range().end
    }
}

impl<'a> FontRead<'a> for KindsOfArrays<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        if data.len() < Self::MIN_SIZE {
            return Err(ReadError::OutOfBounds);
        }
        Ok(Self {
            data,
            shape: KindsOfArraysMarker {},
        })
    }
}

impl ReadArgs for KindsOfArrays<'_> {
    type Args = ();
}

impl<'a> FontReadWithArgs<'a> for KindsOfArrays<'a> {
    fn read_with_args(data: FontData<'a>, _: &Self::Args) -> Result<Self, ReadError> {
        Self::read(data)
    }
}

impl<'a> Sanitize<'a> for KindsOfArrays<'a> {
    #[allow(unused_variables)]
    fn sanitize_impl(&self) -> Result<(), ReadError> {
        let offset_data = self.offset_data();
        Ok(())
    }
}

impl<'a> Sanitized<KindsOfArrays<'a>> {
    pub fn version(&self) -> u16 {
        let range = self.0.version_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }

    /// the number of items in each array
    pub fn count(&self) -> u16 {
        let range = self.0.count_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }

    /// an array of scalars
    pub fn scalars(&self) -> &'a [BigEndian<u16>] {
        let range = self.0.scalars_byte_range();
        unsafe { self.0.data.read_array_unchecked(range) }
    }

    /// an array of records
    pub fn records(&self) -> &'a [Sanitized<Shmecord>] {
        let range = self.0.records_byte_range();
        unsafe { self.0.data.read_array_unchecked(range) }
    }

    /// a versioned array of scalars
    pub fn versioned_scalars(&self) -> Option<&'a [BigEndian<u16>]> {
        let range = self.0.versioned_scalars_byte_range();
        Some(unsafe { self.0.data.read_array_unchecked(range) })
    }

    /// a versioned array of scalars
    pub fn versioned_records(&self) -> Option<&'a [Sanitized<Shmecord>]> {
        let range = self.0.versioned_records_byte_range();
        Some(unsafe { self.0.data.read_array_unchecked(range) })
    }
}

pub type KindsOfArrays<'a> = TableRef<'a, KindsOfArraysMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> KindsOfArrays<'a> {
    pub const MIN_SIZE: usize = (u16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN);

    pub fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        let end = start + u16::RAW_BYTE_LEN;
        start..end
    }

    pub fn count_byte_range(&self) -> Range<usize> {
        let start = self.version_byte_range().end;
        let end = start + u16::RAW_BYTE_LEN;
        start..end
    }

    pub fn scalars_byte_range(&self) -> Range<usize> {
        let count = self.count();
        let start = self.count_byte_range().end;
        let end = start + (count as usize).saturating_mul(u16::RAW_BYTE_LEN);
        start..end
    }

    pub fn records_byte_range(&self) -> Range<usize> {
        let count = self.count();
        let start = self.scalars_byte_range().end;
        let end = start + (count as usize).saturating_mul(Shmecord::RAW_BYTE_LEN);
        start..end
    }

    pub fn versioned_scalars_byte_range(&self) -> Range<usize> {
        let count = self.count();
        let start = self.records_byte_range().end;
        let end = (self.version().compatible(1u16))
            .then(|| start + (count as usize).saturating_mul(u16::RAW_BYTE_LEN))
            .unwrap_or(start);
        start..end
    }

    pub fn versioned_records_byte_range(&self) -> Range<usize> {
        let count = self.count();
        let start = self.versioned_scalars_byte_range().end;
        let end = (self.version().compatible(1u16))
            .then(|| start + (count as usize).saturating_mul(Shmecord::RAW_BYTE_LEN))
            .unwrap_or(start);
        start..end
    }

    pub fn version(&self) -> u16 {
        let range = self.version_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// the number of items in each array
    pub fn count(&self) -> u16 {
        let range = self.count_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// an array of scalars
    pub fn scalars(&self) -> &'a [BigEndian<u16>] {
        let range = self.scalars_byte_range();
        unsafe { self.data.read_array_unchecked(range) }
    }

    /// an array of records
    pub fn records(&self) -> &'a [Shmecord] {
        let range = self.records_byte_range();
        unsafe { self.data.read_array_unchecked(range) }
    }

    /// a versioned array of scalars
    pub fn versioned_scalars(&self) -> Option<&'a [BigEndian<u16>]> {
        let range = self.versioned_scalars_byte_range();
        (!range.is_empty()).then(|| unsafe { self.data.read_array_unchecked(range) })
    }

    /// a versioned array of scalars
    pub fn versioned_records(&self) -> Option<&'a [Shmecord]> {
        let range = self.versioned_records_byte_range();
        (!range.is_empty()).then(|| unsafe { self.data.read_array_unchecked(range) })
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for KindsOfArrays<'a> {
    fn type_name(&self) -> &str {
        "KindsOfArrays"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("version", self.version())),
            1usize => Some(Field::new("count", self.count())),
            2usize => Some(Field::new("scalars", self.scalars())),
            3usize => Some(Field::new(
                "records",
                traversal::FieldType::array_of_records(
                    stringify!(Shmecord),
                    self.records(),
                    self.offset_data(),
                ),
            )),
            4usize if self.version().compatible(1u16) => Some(Field::new(
                "versioned_scalars",
                self.versioned_scalars().unwrap(),
            )),
            5usize if self.version().compatible(1u16) => Some(Field::new(
                "versioned_records",
                traversal::FieldType::array_of_records(
                    stringify!(Shmecord),
                    self.versioned_records().unwrap(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for KindsOfArrays<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct VarLenHaverMarker {}

impl<'a> MinByteRange for VarLenHaver<'a> {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.other_field_byte_range().end
    }
}

impl<'a> FontRead<'a> for VarLenHaver<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        if data.len() < Self::MIN_SIZE {
            return Err(ReadError::OutOfBounds);
        }
        Ok(Self {
            data,
            shape: VarLenHaverMarker {},
        })
    }
}

impl ReadArgs for VarLenHaver<'_> {
    type Args = ();
}

impl<'a> FontReadWithArgs<'a> for VarLenHaver<'a> {
    fn read_with_args(data: FontData<'a>, _: &Self::Args) -> Result<Self, ReadError> {
        Self::read(data)
    }
}

impl<'a> Sanitize<'a> for VarLenHaver<'a> {
    #[allow(unused_variables)]
    fn sanitize_impl(&self) -> Result<(), ReadError> {
        let offset_data = self.offset_data();
        compile_error!("maybe these need annotations?");
        Ok(())
    }
}

impl<'a> Sanitized<VarLenHaver<'a>> {
    pub fn count(&self) -> u16 {
        let range = self.0.count_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }

    pub fn var_len(&self) -> VarLenArray<'a, VarSizeDummy> {
        let range = self.0.var_len_byte_range();
        VarLenArray::read(self.0.data.split_off(range.start).unwrap()).unwrap()
    }

    pub fn other_field(&self) -> u32 {
        let range = self.0.other_field_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }
}

pub type VarLenHaver<'a> = TableRef<'a, VarLenHaverMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> VarLenHaver<'a> {
    pub const MIN_SIZE: usize = (u16::RAW_BYTE_LEN + u32::RAW_BYTE_LEN);

    pub fn count_byte_range(&self) -> Range<usize> {
        let start = 0;
        let end = start + u16::RAW_BYTE_LEN;
        start..end
    }

    pub fn var_len_byte_range(&self) -> Range<usize> {
        let count = self.count();
        let start = self.count_byte_range().end;
        let end = start + {
            let data = self.data.split_off(start).unwrap_or_default();
            <VarSizeDummy as VarSize>::total_len_for_count(data, count as usize).unwrap_or(0)
        };
        start..end
    }

    pub fn other_field_byte_range(&self) -> Range<usize> {
        let start = self.var_len_byte_range().end;
        let end = start + u32::RAW_BYTE_LEN;
        start..end
    }

    pub fn count(&self) -> u16 {
        let range = self.count_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    pub fn var_len(&self) -> VarLenArray<'a, VarSizeDummy> {
        let range = self.var_len_byte_range();
        VarLenArray::read(self.data.split_off(range.start).unwrap()).unwrap()
    }

    pub fn other_field(&self) -> u32 {
        let range = self.other_field_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for VarLenHaver<'a> {
    fn type_name(&self) -> &str {
        "VarLenHaver"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("count", self.count())),
            1usize => Some(Field::new("var_len", traversal::FieldType::Unknown)),
            2usize => Some(Field::new("other_field", self.other_field())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for VarLenHaver<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct DummyMarker {}

impl<'a> MinByteRange for Dummy<'a> {
    fn min_byte_range(&self) -> Range<usize> {
        0..self._reserved_byte_range().end
    }
}

impl<'a> FontRead<'a> for Dummy<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        if data.len() < Self::MIN_SIZE {
            return Err(ReadError::OutOfBounds);
        }
        Ok(Self {
            data,
            shape: DummyMarker {},
        })
    }
}

impl ReadArgs for Dummy<'_> {
    type Args = ();
}

impl<'a> FontReadWithArgs<'a> for Dummy<'a> {
    fn read_with_args(data: FontData<'a>, _: &Self::Args) -> Result<Self, ReadError> {
        Self::read(data)
    }
}

impl<'a> Sanitize<'a> for Dummy<'a> {
    #[allow(unused_variables)]
    fn sanitize_impl(&self) -> Result<(), ReadError> {
        let offset_data = self.offset_data();
        Ok(())
    }
}

impl<'a> Sanitized<Dummy<'a>> {
    pub fn value(&self) -> u16 {
        let range = self.0.value_byte_range();
        unsafe { self.0.data.read_at_unchecked(range.start) }
    }
}

pub type Dummy<'a> = TableRef<'a, DummyMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> Dummy<'a> {
    pub const MIN_SIZE: usize = (u16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN);

    pub fn value_byte_range(&self) -> Range<usize> {
        let start = 0;
        let end = start + u16::RAW_BYTE_LEN;
        start..end
    }

    pub fn _reserved_byte_range(&self) -> Range<usize> {
        let start = self.value_byte_range().end;
        let end = start + u16::RAW_BYTE_LEN;
        start..end
    }

    pub fn value(&self) -> u16 {
        let range = self.value_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for Dummy<'a> {
    fn type_name(&self) -> &str {
        "Dummy"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("value", self.value())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for Dummy<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct Shmecord {
    pub length: BigEndian<u16>,
    pub breadth: BigEndian<u32>,
}

impl Shmecord {
    pub fn length(&self) -> u16 {
        self.length.get()
    }

    pub fn breadth(&self) -> u32 {
        self.breadth.get()
    }
}

impl FixedSize for Shmecord {
    const RAW_BYTE_LEN: usize = u16::RAW_BYTE_LEN + u32::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for Shmecord {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "Shmecord",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("length", self.length())),
                1usize => Some(Field::new("breadth", self.breadth())),
                _ => None,
            }),
            data,
        }
    }
}
