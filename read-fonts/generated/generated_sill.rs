// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Sill {
    /// A power of two > num_langs
    pub next_power_of_two: u16,
    /// Rounded base-2 log of num_langs
    pub log: u16,
    /// Difference between next_power_of_two and num_langs
    pub power_diff: i16,
    pub languages: Vec<Language>,
}

impl Sill {
    /// Construct a new `Sill`
    pub fn new(
        next_power_of_two: u16,
        log: u16,
        power_diff: i16,
        languages: Vec<Language>,
    ) -> Self {
        Self {
            next_power_of_two,
            log,
            power_diff,
            languages,
        }
    }
}

impl FontWrite for Sill {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        let version = self.compute_version() as MajorMinor;
        version.write_into(writer);
        (u16::try_from(array_len(&self.languages)).unwrap()).write_into(writer);
        self.next_power_of_two.write_into(writer);
        self.log.write_into(writer);
        self.power_diff.write_into(writer);
        self.languages.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::TopLevel(Sill::TAG)
    }
}

impl Validate for Sill {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Sill", |ctx| {
            ctx.in_field("languages", |ctx| {
                if self.languages.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.languages.validate_impl(ctx);
            });
        })
    }
}

impl TopLevelTable for Sill {
    const TAG: Tag = Tag::new(b"Sill");
}

impl<'a> FromObjRef<read_fonts::tables::sill::Sill<'a>> for Sill {
    fn from_obj_ref(obj: &read_fonts::tables::sill::Sill<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        Sill {
            next_power_of_two: obj.next_power_of_two(),
            log: obj.log(),
            power_diff: obj.power_diff(),
            languages: obj.languages().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::sill::Sill<'a>> for Sill {}

impl<'a> FontRead<'a> for Sill {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::sill::Sill as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Language {
    pub language: Tag,
    pub settings: OffsetMarker<Vec<SettingName>, WIDTH_32>,
}

impl Language {
    /// Construct a new `Language`
    pub fn new(language: Tag, settings: Vec<SettingName>) -> Self {
        Self {
            language,
            settings: settings.into(),
        }
    }
}

impl FontWrite for Language {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        self.language.write_into(writer);
        (u16::try_from(array_len(&self.settings)).unwrap()).write_into(writer);
        self.settings.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("Language")
    }
}

impl Validate for Language {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Language", |ctx| {
            ctx.in_field("settings", |ctx| {
                self.settings.validate_impl(ctx);
            });
        })
    }
}

impl FromObjRef<read_fonts::tables::sill::Language> for Language {
    fn from_obj_ref(obj: &read_fonts::tables::sill::Language, offset_data: FontData) -> Self {
        Language {
            language: obj.language(),
            settings: obj.settings(offset_data).to_owned_obj(offset_data),
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SettingName {
    pub value: u16,
    pub name: NameId,
}

impl SettingName {
    /// Construct a new `SettingName`
    pub fn new(value: u16, name: NameId) -> Self {
        Self { value, name }
    }
}

impl FontWrite for SettingName {
    fn write_into(&self, writer: &mut TableWriter) {
        self.value.write_into(writer);
        self.name.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("SettingName")
    }
}

impl Validate for SettingName {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl FromObjRef<read_fonts::tables::sill::SettingName> for SettingName {
    fn from_obj_ref(obj: &read_fonts::tables::sill::SettingName, _: FontData) -> Self {
        SettingName {
            value: obj.value(),
            name: obj.name(),
        }
    }
}
