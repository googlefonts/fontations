// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[repr(u16)]
#[allow(clippy::manual_non_exhaustive)]
pub enum MyEnum1 {
    /// doc me baby
    /// docington bear
    #[default]
    ItsAZero = 0,
    ItsAOne = 1,
    #[doc(hidden)]
    /// If font data is malformed we will map unknown values to this variant
    Unknown,
}

impl MyEnum1 {
    /// Create from a raw scalar.
    ///
    /// This will never fail; unknown values will be mapped to the `Unknown` variant
    pub fn new(raw: u16) -> Self {
        match raw {
            0 => Self::ItsAZero,
            1 => Self::ItsAOne,
            _ => Self::Unknown,
        }
    }
}

impl font_types::Scalar for MyEnum1 {
    type Raw = <u16 as font_types::Scalar>::Raw;
    fn to_raw(self) -> Self::Raw {
        (self as u16).to_raw()
    }
    fn from_raw(raw: Self::Raw) -> Self {
        let t = <u16>::from_raw(raw);
        Self::new(t)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> From<MyEnum1> for FieldType<'a> {
    fn from(src: MyEnum1) -> FieldType<'a> {
        (src as u16).into()
    }
}

#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[repr(u16)]
#[allow(clippy::manual_non_exhaustive)]
pub enum MyEnum2 {
    ItsATwo = 2,
    /// A very important three
    #[default]
    ItsAThree = 3,
    #[doc(hidden)]
    /// If font data is malformed we will map unknown values to this variant
    Unknown,
}

impl MyEnum2 {
    /// Create from a raw scalar.
    ///
    /// This will never fail; unknown values will be mapped to the `Unknown` variant
    pub fn new(raw: u16) -> Self {
        match raw {
            2 => Self::ItsATwo,
            3 => Self::ItsAThree,
            _ => Self::Unknown,
        }
    }
}

impl font_types::Scalar for MyEnum2 {
    type Raw = <u16 as font_types::Scalar>::Raw;
    fn to_raw(self) -> Self::Raw {
        (self as u16).to_raw()
    }
    fn from_raw(raw: Self::Raw) -> Self {
        let t = <u16>::from_raw(raw);
        Self::new(t)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> From<MyEnum2> for FieldType<'a> {
    fn from(src: MyEnum2) -> FieldType<'a> {
        (src as u16).into()
    }
}

#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct MyRecord {
    pub my_enum1: BigEndian<MyEnum1>,
    pub my_enum2: BigEndian<MyEnum2>,
}

impl MyRecord {
    pub fn my_enum1(&self) -> MyEnum1 {
        self.my_enum1.get()
    }

    pub fn my_enum2(&self) -> MyEnum2 {
        self.my_enum2.get()
    }
}

impl FixedSize for MyRecord {
    const RAW_BYTE_LEN: usize = MyEnum1::RAW_BYTE_LEN + MyEnum2::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for MyRecord {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "MyRecord",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("my_enum1", self.my_enum1())),
                1usize => Some(Field::new("my_enum2", self.my_enum2())),
                _ => None,
            }),
            data,
        }
    }
}
