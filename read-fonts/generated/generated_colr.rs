// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct ColrFixedFields {
    pub version: BigEndian<u16>,
    pub num_base_glyph_records: BigEndian<u16>,
    pub base_glyph_records_offset: BigEndian<Nullable<Offset32>>,
    pub layer_records_offset: BigEndian<Nullable<Offset32>>,
    pub num_layer_records: BigEndian<u16>,
}

impl FixedSize for ColrFixedFields {
    const RAW_BYTE_LEN: usize = u16::RAW_BYTE_LEN
        + u16::RAW_BYTE_LEN
        + Offset32::RAW_BYTE_LEN
        + Offset32::RAW_BYTE_LEN
        + u16::RAW_BYTE_LEN;
}

/// [COLR (Color)](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#colr-header) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct ColrMarker {
    base_glyph_list_offset_byte_start: Option<usize>,
    layer_list_offset_byte_start: Option<usize>,
    clip_list_offset_byte_start: Option<usize>,
    var_index_map_offset_byte_start: Option<usize>,
    item_variation_store_offset_byte_start: Option<usize>,
}

impl ColrMarker {
    pub fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn num_base_glyph_records_byte_range(&self) -> Range<usize> {
        let start = self.version_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn base_glyph_records_offset_byte_range(&self) -> Range<usize> {
        let start = self.num_base_glyph_records_byte_range().end;
        start..start + Offset32::RAW_BYTE_LEN
    }

    pub fn layer_records_offset_byte_range(&self) -> Range<usize> {
        let start = self.base_glyph_records_offset_byte_range().end;
        start..start + Offset32::RAW_BYTE_LEN
    }

    pub fn num_layer_records_byte_range(&self) -> Range<usize> {
        let start = self.layer_records_offset_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn base_glyph_list_offset_byte_range(&self) -> Option<Range<usize>> {
        let start = self.base_glyph_list_offset_byte_start?;
        Some(start..start + Offset32::RAW_BYTE_LEN)
    }

    pub fn layer_list_offset_byte_range(&self) -> Option<Range<usize>> {
        let start = self.layer_list_offset_byte_start?;
        Some(start..start + Offset32::RAW_BYTE_LEN)
    }

    pub fn clip_list_offset_byte_range(&self) -> Option<Range<usize>> {
        let start = self.clip_list_offset_byte_start?;
        Some(start..start + Offset32::RAW_BYTE_LEN)
    }

    pub fn var_index_map_offset_byte_range(&self) -> Option<Range<usize>> {
        let start = self.var_index_map_offset_byte_start?;
        Some(start..start + Offset32::RAW_BYTE_LEN)
    }

    pub fn item_variation_store_offset_byte_range(&self) -> Option<Range<usize>> {
        let start = self.item_variation_store_offset_byte_start?;
        Some(start..start + Offset32::RAW_BYTE_LEN)
    }
}

impl MinByteRange for ColrMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.num_layer_records_byte_range().end
    }
}

impl TopLevelTable for Colr<'_> {
    /// `COLR`
    const TAG: Tag = Tag::new(b"COLR");
}

impl<'a> FontRead<'a> for Colr<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a ColrFixedFields = cursor.read_ref()?;
        let version = fixed_fields.version.get();
        let base_glyph_list_offset_byte_start = version
            .compatible(1u16)
            .then(|| cursor.position())
            .transpose()?;
        version
            .compatible(1u16)
            .then(|| cursor.advance::<Offset32>());
        let layer_list_offset_byte_start = version
            .compatible(1u16)
            .then(|| cursor.position())
            .transpose()?;
        version
            .compatible(1u16)
            .then(|| cursor.advance::<Offset32>());
        let clip_list_offset_byte_start = version
            .compatible(1u16)
            .then(|| cursor.position())
            .transpose()?;
        version
            .compatible(1u16)
            .then(|| cursor.advance::<Offset32>());
        let var_index_map_offset_byte_start = version
            .compatible(1u16)
            .then(|| cursor.position())
            .transpose()?;
        version
            .compatible(1u16)
            .then(|| cursor.advance::<Offset32>());
        let item_variation_store_offset_byte_start = version
            .compatible(1u16)
            .then(|| cursor.position())
            .transpose()?;
        version
            .compatible(1u16)
            .then(|| cursor.advance::<Offset32>());
        cursor.finish(
            ColrMarker {
                base_glyph_list_offset_byte_start,
                layer_list_offset_byte_start,
                clip_list_offset_byte_start,
                var_index_map_offset_byte_start,
                item_variation_store_offset_byte_start,
            },
            fixed_fields,
        )
    }
}

/// [COLR (Color)](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#colr-header) table
pub type Colr<'a> = TableRef<'a, ColrMarker, ColrFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> Colr<'a> {
    /// Table version number - set to 0 or 1.
    #[inline]
    pub fn version(&self) -> u16 {
        self.fixed_fields().version.get()
    }

    /// Number of BaseGlyph records; may be 0 in a version 1 table.
    #[inline]
    pub fn num_base_glyph_records(&self) -> u16 {
        self.fixed_fields().num_base_glyph_records.get()
    }

    /// Offset to baseGlyphRecords array (may be NULL).
    #[inline]
    pub fn base_glyph_records_offset(&self) -> Nullable<Offset32> {
        self.fixed_fields().base_glyph_records_offset.get()
    }

    /// Attempt to resolve [`base_glyph_records_offset`][Self::base_glyph_records_offset].
    #[inline]
    pub fn base_glyph_records(&self) -> Option<Result<&'a [BaseGlyph], ReadError>> {
        let data = self.data;
        let args = self.num_base_glyph_records();
        self.base_glyph_records_offset()
            .resolve_with_args(data, &args)
    }

    /// Offset to layerRecords array (may be NULL).
    #[inline]
    pub fn layer_records_offset(&self) -> Nullable<Offset32> {
        self.fixed_fields().layer_records_offset.get()
    }

    /// Attempt to resolve [`layer_records_offset`][Self::layer_records_offset].
    #[inline]
    pub fn layer_records(&self) -> Option<Result<&'a [Layer], ReadError>> {
        let data = self.data;
        let args = self.num_layer_records();
        self.layer_records_offset().resolve_with_args(data, &args)
    }

    /// Number of Layer records; may be 0 in a version 1 table.
    #[inline]
    pub fn num_layer_records(&self) -> u16 {
        self.fixed_fields().num_layer_records.get()
    }

    /// Offset to BaseGlyphList table.
    #[inline]
    pub fn base_glyph_list_offset(&self) -> Option<Nullable<Offset32>> {
        let range = self.shape.base_glyph_list_offset_byte_range()?;
        Some(self.data.read_at(range.start).unwrap())
    }

    /// Attempt to resolve [`base_glyph_list_offset`][Self::base_glyph_list_offset].
    #[inline]
    pub fn base_glyph_list(&self) -> Option<Result<BaseGlyphList<'a>, ReadError>> {
        let data = self.data;
        self.base_glyph_list_offset().map(|x| x.resolve(data))?
    }

    /// Offset to LayerList table (may be NULL).
    #[inline]
    pub fn layer_list_offset(&self) -> Option<Nullable<Offset32>> {
        let range = self.shape.layer_list_offset_byte_range()?;
        Some(self.data.read_at(range.start).unwrap())
    }

    /// Attempt to resolve [`layer_list_offset`][Self::layer_list_offset].
    #[inline]
    pub fn layer_list(&self) -> Option<Result<LayerList<'a>, ReadError>> {
        let data = self.data;
        self.layer_list_offset().map(|x| x.resolve(data))?
    }

    /// Offset to ClipList table (may be NULL).
    #[inline]
    pub fn clip_list_offset(&self) -> Option<Nullable<Offset32>> {
        let range = self.shape.clip_list_offset_byte_range()?;
        Some(self.data.read_at(range.start).unwrap())
    }

    /// Attempt to resolve [`clip_list_offset`][Self::clip_list_offset].
    #[inline]
    pub fn clip_list(&self) -> Option<Result<ClipList<'a>, ReadError>> {
        let data = self.data;
        self.clip_list_offset().map(|x| x.resolve(data))?
    }

    /// Offset to DeltaSetIndexMap table (may be NULL).
    #[inline]
    pub fn var_index_map_offset(&self) -> Option<Nullable<Offset32>> {
        let range = self.shape.var_index_map_offset_byte_range()?;
        Some(self.data.read_at(range.start).unwrap())
    }

    /// Attempt to resolve [`var_index_map_offset`][Self::var_index_map_offset].
    #[inline]
    pub fn var_index_map(&self) -> Option<Result<DeltaSetIndexMap<'a>, ReadError>> {
        let data = self.data;
        self.var_index_map_offset().map(|x| x.resolve(data))?
    }

    /// Offset to ItemVariationStore (may be NULL).
    #[inline]
    pub fn item_variation_store_offset(&self) -> Option<Nullable<Offset32>> {
        let range = self.shape.item_variation_store_offset_byte_range()?;
        Some(self.data.read_at(range.start).unwrap())
    }

    /// Attempt to resolve [`item_variation_store_offset`][Self::item_variation_store_offset].
    #[inline]
    pub fn item_variation_store(&self) -> Option<Result<ItemVariationStore<'a>, ReadError>> {
        let data = self.data;
        self.item_variation_store_offset()
            .map(|x| x.resolve(data))?
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for Colr<'a> {
    fn type_name(&self) -> &str {
        "Colr"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        let version = self.version();
        match idx {
            0usize => Some(Field::new("version", self.version())),
            1usize => Some(Field::new(
                "num_base_glyph_records",
                self.num_base_glyph_records(),
            )),
            2usize => Some(Field::new(
                "base_glyph_records_offset",
                traversal::FieldType::offset_to_array_of_records(
                    self.base_glyph_records_offset(),
                    self.base_glyph_records(),
                    stringify!(BaseGlyph),
                    self.offset_data(),
                ),
            )),
            3usize => Some(Field::new(
                "layer_records_offset",
                traversal::FieldType::offset_to_array_of_records(
                    self.layer_records_offset(),
                    self.layer_records(),
                    stringify!(Layer),
                    self.offset_data(),
                ),
            )),
            4usize => Some(Field::new("num_layer_records", self.num_layer_records())),
            5usize if version.compatible(1u16) => Some(Field::new(
                "base_glyph_list_offset",
                FieldType::offset(
                    self.base_glyph_list_offset().unwrap(),
                    self.base_glyph_list(),
                ),
            )),
            6usize if version.compatible(1u16) => Some(Field::new(
                "layer_list_offset",
                FieldType::offset(self.layer_list_offset().unwrap(), self.layer_list()),
            )),
            7usize if version.compatible(1u16) => Some(Field::new(
                "clip_list_offset",
                FieldType::offset(self.clip_list_offset().unwrap(), self.clip_list()),
            )),
            8usize if version.compatible(1u16) => Some(Field::new(
                "var_index_map_offset",
                FieldType::offset(self.var_index_map_offset().unwrap(), self.var_index_map()),
            )),
            9usize if version.compatible(1u16) => Some(Field::new(
                "item_variation_store_offset",
                FieldType::offset(
                    self.item_variation_store_offset().unwrap(),
                    self.item_variation_store(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for Colr<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [BaseGlyph](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyph-and-layer-records) record
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct BaseGlyph {
    /// Glyph ID of the base glyph.
    pub glyph_id: BigEndian<GlyphId16>,
    /// Index (base 0) into the layerRecords array.
    pub first_layer_index: BigEndian<u16>,
    /// Number of color layers associated with this glyph.
    pub num_layers: BigEndian<u16>,
}

impl BaseGlyph {
    /// Glyph ID of the base glyph.
    #[inline]
    pub fn glyph_id(&self) -> GlyphId16 {
        self.glyph_id.get()
    }

    /// Index (base 0) into the layerRecords array.
    #[inline]
    pub fn first_layer_index(&self) -> u16 {
        self.first_layer_index.get()
    }

    /// Number of color layers associated with this glyph.
    #[inline]
    pub fn num_layers(&self) -> u16 {
        self.num_layers.get()
    }
}

impl FixedSize for BaseGlyph {
    const RAW_BYTE_LEN: usize = GlyphId16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for BaseGlyph {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "BaseGlyph",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("glyph_id", self.glyph_id())),
                1usize => Some(Field::new("first_layer_index", self.first_layer_index())),
                2usize => Some(Field::new("num_layers", self.num_layers())),
                _ => None,
            }),
            data,
        }
    }
}

/// [Layer](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyph-and-layer-records) record
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct Layer {
    /// Glyph ID of the glyph used for a given layer.
    pub glyph_id: BigEndian<GlyphId16>,
    /// Index (base 0) for a palette entry in the CPAL table.
    pub palette_index: BigEndian<u16>,
}

impl Layer {
    /// Glyph ID of the glyph used for a given layer.
    #[inline]
    pub fn glyph_id(&self) -> GlyphId16 {
        self.glyph_id.get()
    }

    /// Index (base 0) for a palette entry in the CPAL table.
    #[inline]
    pub fn palette_index(&self) -> u16 {
        self.palette_index.get()
    }
}

impl FixedSize for Layer {
    const RAW_BYTE_LEN: usize = GlyphId16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for Layer {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "Layer",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("glyph_id", self.glyph_id())),
                1usize => Some(Field::new("palette_index", self.palette_index())),
                _ => None,
            }),
            data,
        }
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct BaseGlyphListFixedFields {
    pub num_base_glyph_paint_records: BigEndian<u32>,
}

impl FixedSize for BaseGlyphListFixedFields {
    const RAW_BYTE_LEN: usize = u32::RAW_BYTE_LEN;
}

/// [BaseGlyphList](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct BaseGlyphListMarker {
    base_glyph_paint_records_byte_len: usize,
}

impl BaseGlyphListMarker {
    pub fn num_base_glyph_paint_records_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u32::RAW_BYTE_LEN
    }

    pub fn base_glyph_paint_records_byte_range(&self) -> Range<usize> {
        let start = self.num_base_glyph_paint_records_byte_range().end;
        start..start + self.base_glyph_paint_records_byte_len
    }
}

impl MinByteRange for BaseGlyphListMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.base_glyph_paint_records_byte_range().end
    }
}

impl<'a> FontRead<'a> for BaseGlyphList<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a BaseGlyphListFixedFields = cursor.read_ref()?;
        let num_base_glyph_paint_records = fixed_fields.num_base_glyph_paint_records.get();
        let base_glyph_paint_records_byte_len = (num_base_glyph_paint_records as usize)
            .checked_mul(BaseGlyphPaint::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(base_glyph_paint_records_byte_len);
        cursor.finish(
            BaseGlyphListMarker {
                base_glyph_paint_records_byte_len,
            },
            fixed_fields,
        )
    }
}

/// [BaseGlyphList](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) table
pub type BaseGlyphList<'a> = TableRef<'a, BaseGlyphListMarker, BaseGlyphListFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> BaseGlyphList<'a> {
    #[inline]
    pub fn num_base_glyph_paint_records(&self) -> u32 {
        self.fixed_fields().num_base_glyph_paint_records.get()
    }

    #[inline]
    pub fn base_glyph_paint_records(&self) -> &'a [BaseGlyphPaint] {
        let range = self.shape.base_glyph_paint_records_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for BaseGlyphList<'a> {
    fn type_name(&self) -> &str {
        "BaseGlyphList"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new(
                "num_base_glyph_paint_records",
                self.num_base_glyph_paint_records(),
            )),
            1usize => Some(Field::new(
                "base_glyph_paint_records",
                traversal::FieldType::array_of_records(
                    stringify!(BaseGlyphPaint),
                    self.base_glyph_paint_records(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for BaseGlyphList<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [BaseGlyphPaint](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) record
#[derive(Clone, Debug, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct BaseGlyphPaint {
    /// Glyph ID of the base glyph.
    pub glyph_id: BigEndian<GlyphId16>,
    /// Offset to a Paint table, from the beginning of the [`BaseGlyphList`] table.
    pub paint_offset: BigEndian<Offset32>,
}

impl BaseGlyphPaint {
    /// Glyph ID of the base glyph.
    #[inline]
    pub fn glyph_id(&self) -> GlyphId16 {
        self.glyph_id.get()
    }

    /// Offset to a Paint table, from the beginning of the [`BaseGlyphList`] table.
    #[inline]
    pub fn paint_offset(&self) -> Offset32 {
        self.paint_offset.get()
    }

    /// Offset to a Paint table, from the beginning of the [`BaseGlyphList`] table.
    ///
    /// The `data` argument should be retrieved from the parent table
    /// By calling its `offset_data` method.
    #[inline]
    pub fn paint<'a>(&self, data: FontData<'a>) -> Result<Paint<'a>, ReadError> {
        self.paint_offset().resolve(data)
    }
}

impl FixedSize for BaseGlyphPaint {
    const RAW_BYTE_LEN: usize = GlyphId16::RAW_BYTE_LEN + Offset32::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for BaseGlyphPaint {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "BaseGlyphPaint",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("glyph_id", self.glyph_id())),
                1usize => Some(Field::new(
                    "paint_offset",
                    FieldType::offset(self.paint_offset(), self.paint(_data)),
                )),
                _ => None,
            }),
            data,
        }
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct LayerListFixedFields {
    pub num_layers: BigEndian<u32>,
}

impl FixedSize for LayerListFixedFields {
    const RAW_BYTE_LEN: usize = u32::RAW_BYTE_LEN;
}

/// [LayerList](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct LayerListMarker {
    paint_offsets_byte_len: usize,
}

impl LayerListMarker {
    pub fn num_layers_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u32::RAW_BYTE_LEN
    }

    pub fn paint_offsets_byte_range(&self) -> Range<usize> {
        let start = self.num_layers_byte_range().end;
        start..start + self.paint_offsets_byte_len
    }
}

impl MinByteRange for LayerListMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.paint_offsets_byte_range().end
    }
}

impl<'a> FontRead<'a> for LayerList<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a LayerListFixedFields = cursor.read_ref()?;
        let num_layers = fixed_fields.num_layers.get();
        let paint_offsets_byte_len = (num_layers as usize)
            .checked_mul(Offset32::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(paint_offsets_byte_len);
        cursor.finish(
            LayerListMarker {
                paint_offsets_byte_len,
            },
            fixed_fields,
        )
    }
}

/// [LayerList](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) table
pub type LayerList<'a> = TableRef<'a, LayerListMarker, LayerListFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> LayerList<'a> {
    #[inline]
    pub fn num_layers(&self) -> u32 {
        self.fixed_fields().num_layers.get()
    }

    /// Offsets to Paint tables.
    #[inline]
    pub fn paint_offsets(&self) -> &'a [BigEndian<Offset32>] {
        let range = self.shape.paint_offsets_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// A dynamically resolving wrapper for [`paint_offsets`][Self::paint_offsets].
    #[inline]
    pub fn paints(&self) -> ArrayOfOffsets<'a, Paint<'a>, Offset32> {
        let data = self.data;
        let offsets = self.paint_offsets();
        ArrayOfOffsets::new(offsets, data, ())
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for LayerList<'a> {
    fn type_name(&self) -> &str {
        "LayerList"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("num_layers", self.num_layers())),
            1usize => Some({
                let data = self.data;
                Field::new(
                    "paint_offsets",
                    FieldType::array_of_offsets(
                        better_type_name::<Paint>(),
                        self.paint_offsets(),
                        move |off| {
                            let target = off.get().resolve::<Paint>(data);
                            FieldType::offset(off.get(), target)
                        },
                    ),
                )
            }),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for LayerList<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct ClipListFixedFields {
    pub format: u8,
    pub num_clips: BigEndian<u32>,
}

impl FixedSize for ClipListFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN + u32::RAW_BYTE_LEN;
}

/// [ClipList](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct ClipListMarker {
    clips_byte_len: usize,
}

impl ClipListMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn num_clips_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }

    pub fn clips_byte_range(&self) -> Range<usize> {
        let start = self.num_clips_byte_range().end;
        start..start + self.clips_byte_len
    }
}

impl MinByteRange for ClipListMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.clips_byte_range().end
    }
}

impl<'a> FontRead<'a> for ClipList<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a ClipListFixedFields = cursor.read_ref()?;
        let num_clips = fixed_fields.num_clips.get();
        let clips_byte_len = (num_clips as usize)
            .checked_mul(Clip::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(clips_byte_len);
        cursor.finish(ClipListMarker { clips_byte_len }, fixed_fields)
    }
}

/// [ClipList](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) table
pub type ClipList<'a> = TableRef<'a, ClipListMarker, ClipListFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> ClipList<'a> {
    /// Set to 1.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Number of Clip records.
    #[inline]
    pub fn num_clips(&self) -> u32 {
        self.fixed_fields().num_clips.get()
    }

    /// Clip records. Sorted by startGlyphID.
    #[inline]
    pub fn clips(&self) -> &'a [Clip] {
        let range = self.shape.clips_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for ClipList<'a> {
    fn type_name(&self) -> &str {
        "ClipList"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new("num_clips", self.num_clips())),
            2usize => Some(Field::new(
                "clips",
                traversal::FieldType::array_of_records(
                    stringify!(Clip),
                    self.clips(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for ClipList<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [Clip](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) record
#[derive(Clone, Debug, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct Clip {
    /// First glyph ID in the range.
    pub start_glyph_id: BigEndian<GlyphId16>,
    /// Last glyph ID in the range.
    pub end_glyph_id: BigEndian<GlyphId16>,
    /// Offset to a ClipBox table, from the beginning of the [`ClipList`] table.
    pub clip_box_offset: BigEndian<Offset24>,
}

impl Clip {
    /// First glyph ID in the range.
    #[inline]
    pub fn start_glyph_id(&self) -> GlyphId16 {
        self.start_glyph_id.get()
    }

    /// Last glyph ID in the range.
    #[inline]
    pub fn end_glyph_id(&self) -> GlyphId16 {
        self.end_glyph_id.get()
    }

    /// Offset to a ClipBox table, from the beginning of the [`ClipList`] table.
    #[inline]
    pub fn clip_box_offset(&self) -> Offset24 {
        self.clip_box_offset.get()
    }

    /// Offset to a ClipBox table, from the beginning of the [`ClipList`] table.
    ///
    /// The `data` argument should be retrieved from the parent table
    /// By calling its `offset_data` method.
    #[inline]
    pub fn clip_box<'a>(&self, data: FontData<'a>) -> Result<ClipBox<'a>, ReadError> {
        self.clip_box_offset().resolve(data)
    }
}

impl FixedSize for Clip {
    const RAW_BYTE_LEN: usize =
        GlyphId16::RAW_BYTE_LEN + GlyphId16::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for Clip {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "Clip",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("start_glyph_id", self.start_glyph_id())),
                1usize => Some(Field::new("end_glyph_id", self.end_glyph_id())),
                2usize => Some(Field::new(
                    "clip_box_offset",
                    FieldType::offset(self.clip_box_offset(), self.clip_box(_data)),
                )),
                _ => None,
            }),
            data,
        }
    }
}

/// [ClipBox](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) table
#[derive(Clone)]
pub enum ClipBox<'a> {
    Format1(ClipBoxFormat1<'a>),
    Format2(ClipBoxFormat2<'a>),
}

impl<'a> ClipBox<'a> {
    ///Return the `FontData` used to resolve offsets for this table.
    #[inline]
    pub fn offset_data(&self) -> FontData<'a> {
        match self {
            Self::Format1(item) => item.offset_data(),
            Self::Format2(item) => item.offset_data(),
        }
    }

    /// Set to 1.
    #[inline]
    pub fn format(&self) -> u8 {
        match self {
            Self::Format1(item) => item.format(),
            Self::Format2(item) => item.format(),
        }
    }

    /// Minimum x of clip box.
    #[inline]
    pub fn x_min(&self) -> FWord {
        match self {
            Self::Format1(item) => item.x_min(),
            Self::Format2(item) => item.x_min(),
        }
    }

    /// Minimum y of clip box.
    #[inline]
    pub fn y_min(&self) -> FWord {
        match self {
            Self::Format1(item) => item.y_min(),
            Self::Format2(item) => item.y_min(),
        }
    }

    /// Maximum x of clip box.
    #[inline]
    pub fn x_max(&self) -> FWord {
        match self {
            Self::Format1(item) => item.x_max(),
            Self::Format2(item) => item.x_max(),
        }
    }

    /// Maximum y of clip box.
    #[inline]
    pub fn y_max(&self) -> FWord {
        match self {
            Self::Format1(item) => item.y_max(),
            Self::Format2(item) => item.y_max(),
        }
    }
}

impl<'a> FontRead<'a> for ClipBox<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let format: u8 = data.read_at(0usize)?;
        match format {
            ClipBoxFormat1Marker::FORMAT => Ok(Self::Format1(FontRead::read(data)?)),
            ClipBoxFormat2Marker::FORMAT => Ok(Self::Format2(FontRead::read(data)?)),
            other => Err(ReadError::InvalidFormat(other.into())),
        }
    }
}

impl MinByteRange for ClipBox<'_> {
    fn min_byte_range(&self) -> Range<usize> {
        match self {
            Self::Format1(item) => item.min_byte_range(),
            Self::Format2(item) => item.min_byte_range(),
        }
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> ClipBox<'a> {
    fn dyn_inner<'b>(&'b self) -> &'b dyn SomeTable<'a> {
        match self {
            Self::Format1(table) => table,
            Self::Format2(table) => table,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
impl std::fmt::Debug for ClipBox<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.dyn_inner().fmt(f)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for ClipBox<'a> {
    fn type_name(&self) -> &str {
        self.dyn_inner().type_name()
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        self.dyn_inner().get_field(idx)
    }
}

impl Format<u8> for ClipBoxFormat1Marker {
    const FORMAT: u8 = 1;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct ClipBoxFormat1FixedFields {
    pub format: u8,
    pub x_min: BigEndian<FWord>,
    pub y_min: BigEndian<FWord>,
    pub x_max: BigEndian<FWord>,
    pub y_max: BigEndian<FWord>,
}

impl FixedSize for ClipBoxFormat1FixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN;
}

/// [ClipBoxFormat1](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) record
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct ClipBoxFormat1Marker {}

impl ClipBoxFormat1Marker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn x_min_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y_min_byte_range(&self) -> Range<usize> {
        let start = self.x_min_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn x_max_byte_range(&self) -> Range<usize> {
        let start = self.y_min_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y_max_byte_range(&self) -> Range<usize> {
        let start = self.x_max_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }
}

impl MinByteRange for ClipBoxFormat1Marker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.y_max_byte_range().end
    }
}

impl<'a> FontRead<'a> for ClipBoxFormat1<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a ClipBoxFormat1FixedFields = cursor.read_ref()?;
        cursor.finish(ClipBoxFormat1Marker {}, fixed_fields)
    }
}

/// [ClipBoxFormat1](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) record
pub type ClipBoxFormat1<'a> = TableRef<'a, ClipBoxFormat1Marker, ClipBoxFormat1FixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> ClipBoxFormat1<'a> {
    /// Set to 1.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Minimum x of clip box.
    #[inline]
    pub fn x_min(&self) -> FWord {
        self.fixed_fields().x_min.get()
    }

    /// Minimum y of clip box.
    #[inline]
    pub fn y_min(&self) -> FWord {
        self.fixed_fields().y_min.get()
    }

    /// Maximum x of clip box.
    #[inline]
    pub fn x_max(&self) -> FWord {
        self.fixed_fields().x_max.get()
    }

    /// Maximum y of clip box.
    #[inline]
    pub fn y_max(&self) -> FWord {
        self.fixed_fields().y_max.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for ClipBoxFormat1<'a> {
    fn type_name(&self) -> &str {
        "ClipBoxFormat1"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new("x_min", self.x_min())),
            2usize => Some(Field::new("y_min", self.y_min())),
            3usize => Some(Field::new("x_max", self.x_max())),
            4usize => Some(Field::new("y_max", self.y_max())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for ClipBoxFormat1<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for ClipBoxFormat2Marker {
    const FORMAT: u8 = 2;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct ClipBoxFormat2FixedFields {
    pub format: u8,
    pub x_min: BigEndian<FWord>,
    pub y_min: BigEndian<FWord>,
    pub x_max: BigEndian<FWord>,
    pub y_max: BigEndian<FWord>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for ClipBoxFormat2FixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [ClipBoxFormat2](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) record
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct ClipBoxFormat2Marker {}

impl ClipBoxFormat2Marker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn x_min_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y_min_byte_range(&self) -> Range<usize> {
        let start = self.x_min_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn x_max_byte_range(&self) -> Range<usize> {
        let start = self.y_min_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y_max_byte_range(&self) -> Range<usize> {
        let start = self.x_max_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.y_max_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for ClipBoxFormat2Marker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for ClipBoxFormat2<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a ClipBoxFormat2FixedFields = cursor.read_ref()?;
        cursor.finish(ClipBoxFormat2Marker {}, fixed_fields)
    }
}

/// [ClipBoxFormat2](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#baseglyphlist-layerlist-and-cliplist) record
pub type ClipBoxFormat2<'a> = TableRef<'a, ClipBoxFormat2Marker, ClipBoxFormat2FixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> ClipBoxFormat2<'a> {
    /// Set to 2.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Minimum x of clip box. For variation, use varIndexBase + 0.
    #[inline]
    pub fn x_min(&self) -> FWord {
        self.fixed_fields().x_min.get()
    }

    /// Minimum y of clip box. For variation, use varIndexBase + 1.
    #[inline]
    pub fn y_min(&self) -> FWord {
        self.fixed_fields().y_min.get()
    }

    /// Maximum x of clip box. For variation, use varIndexBase + 2.
    #[inline]
    pub fn x_max(&self) -> FWord {
        self.fixed_fields().x_max.get()
    }

    /// Maximum y of clip box. For variation, use varIndexBase + 3.
    #[inline]
    pub fn y_max(&self) -> FWord {
        self.fixed_fields().y_max.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for ClipBoxFormat2<'a> {
    fn type_name(&self) -> &str {
        "ClipBoxFormat2"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new("x_min", self.x_min())),
            2usize => Some(Field::new("y_min", self.y_min())),
            3usize => Some(Field::new("x_max", self.x_max())),
            4usize => Some(Field::new("y_max", self.y_max())),
            5usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for ClipBoxFormat2<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [ColorIndex](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#color-references-colorstop-and-colorline) record
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct ColorIndex {
    /// Index for a CPAL palette entry.
    pub palette_index: BigEndian<u16>,
    /// Alpha value.
    pub alpha: BigEndian<F2Dot14>,
}

impl ColorIndex {
    /// Index for a CPAL palette entry.
    #[inline]
    pub fn palette_index(&self) -> u16 {
        self.palette_index.get()
    }

    /// Alpha value.
    #[inline]
    pub fn alpha(&self) -> F2Dot14 {
        self.alpha.get()
    }
}

impl FixedSize for ColorIndex {
    const RAW_BYTE_LEN: usize = u16::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for ColorIndex {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "ColorIndex",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("palette_index", self.palette_index())),
                1usize => Some(Field::new("alpha", self.alpha())),
                _ => None,
            }),
            data,
        }
    }
}

/// [VarColorIndex](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#color-references-colorstop-and-colorline) record
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct VarColorIndex {
    /// Index for a CPAL palette entry.
    pub palette_index: BigEndian<u16>,
    /// Alpha value. For variation, use varIndexBase + 0.
    pub alpha: BigEndian<F2Dot14>,
    /// Base index into DeltaSetIndexMap.
    pub var_index_base: BigEndian<u32>,
}

impl VarColorIndex {
    /// Index for a CPAL palette entry.
    #[inline]
    pub fn palette_index(&self) -> u16 {
        self.palette_index.get()
    }

    /// Alpha value. For variation, use varIndexBase + 0.
    #[inline]
    pub fn alpha(&self) -> F2Dot14 {
        self.alpha.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.var_index_base.get()
    }
}

impl FixedSize for VarColorIndex {
    const RAW_BYTE_LEN: usize = u16::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN + u32::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for VarColorIndex {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "VarColorIndex",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("palette_index", self.palette_index())),
                1usize => Some(Field::new("alpha", self.alpha())),
                2usize => Some(Field::new("var_index_base", self.var_index_base())),
                _ => None,
            }),
            data,
        }
    }
}

/// [ColorStop](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#color-references-colorstop-and-colorline) record
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct ColorStop {
    /// Position on a color line.
    pub stop_offset: BigEndian<F2Dot14>,
    /// Index for a CPAL palette entry.
    pub palette_index: BigEndian<u16>,
    /// Alpha value.
    pub alpha: BigEndian<F2Dot14>,
}

impl ColorStop {
    /// Position on a color line.
    #[inline]
    pub fn stop_offset(&self) -> F2Dot14 {
        self.stop_offset.get()
    }

    /// Index for a CPAL palette entry.
    #[inline]
    pub fn palette_index(&self) -> u16 {
        self.palette_index.get()
    }

    /// Alpha value.
    #[inline]
    pub fn alpha(&self) -> F2Dot14 {
        self.alpha.get()
    }
}

impl FixedSize for ColorStop {
    const RAW_BYTE_LEN: usize = F2Dot14::RAW_BYTE_LEN + u16::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for ColorStop {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "ColorStop",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("stop_offset", self.stop_offset())),
                1usize => Some(Field::new("palette_index", self.palette_index())),
                2usize => Some(Field::new("alpha", self.alpha())),
                _ => None,
            }),
            data,
        }
    }
}

/// [VarColorStop](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#color-references-colorstop-and-colorline) record
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct VarColorStop {
    /// Position on a color line. For variation, use varIndexBase + 0.
    pub stop_offset: BigEndian<F2Dot14>,
    /// Index for a CPAL palette entry.
    pub palette_index: BigEndian<u16>,
    /// Alpha value. For variation, use varIndexBase + 1.
    pub alpha: BigEndian<F2Dot14>,
    /// Base index into DeltaSetIndexMap.
    pub var_index_base: BigEndian<u32>,
}

impl VarColorStop {
    /// Position on a color line. For variation, use varIndexBase + 0.
    #[inline]
    pub fn stop_offset(&self) -> F2Dot14 {
        self.stop_offset.get()
    }

    /// Index for a CPAL palette entry.
    #[inline]
    pub fn palette_index(&self) -> u16 {
        self.palette_index.get()
    }

    /// Alpha value. For variation, use varIndexBase + 1.
    #[inline]
    pub fn alpha(&self) -> F2Dot14 {
        self.alpha.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.var_index_base.get()
    }
}

impl FixedSize for VarColorStop {
    const RAW_BYTE_LEN: usize =
        F2Dot14::RAW_BYTE_LEN + u16::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN + u32::RAW_BYTE_LEN;
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for VarColorStop {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "VarColorStop",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new("stop_offset", self.stop_offset())),
                1usize => Some(Field::new("palette_index", self.palette_index())),
                2usize => Some(Field::new("alpha", self.alpha())),
                3usize => Some(Field::new("var_index_base", self.var_index_base())),
                _ => None,
            }),
            data,
        }
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct ColorLineFixedFields {
    pub extend: BigEndian<Extend>,
    pub num_stops: BigEndian<u16>,
}

impl FixedSize for ColorLineFixedFields {
    const RAW_BYTE_LEN: usize = Extend::RAW_BYTE_LEN + u16::RAW_BYTE_LEN;
}

/// [ColorLine](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#color-references-colorstop-and-colorline) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct ColorLineMarker {
    color_stops_byte_len: usize,
}

impl ColorLineMarker {
    pub fn extend_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + Extend::RAW_BYTE_LEN
    }

    pub fn num_stops_byte_range(&self) -> Range<usize> {
        let start = self.extend_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn color_stops_byte_range(&self) -> Range<usize> {
        let start = self.num_stops_byte_range().end;
        start..start + self.color_stops_byte_len
    }
}

impl MinByteRange for ColorLineMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.color_stops_byte_range().end
    }
}

impl<'a> FontRead<'a> for ColorLine<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a ColorLineFixedFields = cursor.read_ref()?;
        let num_stops = fixed_fields.num_stops.get();
        let color_stops_byte_len = (num_stops as usize)
            .checked_mul(ColorStop::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(color_stops_byte_len);
        cursor.finish(
            ColorLineMarker {
                color_stops_byte_len,
            },
            fixed_fields,
        )
    }
}

/// [ColorLine](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#color-references-colorstop-and-colorline) table
pub type ColorLine<'a> = TableRef<'a, ColorLineMarker, ColorLineFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> ColorLine<'a> {
    /// An Extend enum value.
    #[inline]
    pub fn extend(&self) -> Extend {
        self.fixed_fields().extend.get()
    }

    /// Number of ColorStop records.
    #[inline]
    pub fn num_stops(&self) -> u16 {
        self.fixed_fields().num_stops.get()
    }

    #[inline]
    pub fn color_stops(&self) -> &'a [ColorStop] {
        let range = self.shape.color_stops_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for ColorLine<'a> {
    fn type_name(&self) -> &str {
        "ColorLine"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("extend", self.extend())),
            1usize => Some(Field::new("num_stops", self.num_stops())),
            2usize => Some(Field::new(
                "color_stops",
                traversal::FieldType::array_of_records(
                    stringify!(ColorStop),
                    self.color_stops(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for ColorLine<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct VarColorLineFixedFields {
    pub extend: BigEndian<Extend>,
    pub num_stops: BigEndian<u16>,
}

impl FixedSize for VarColorLineFixedFields {
    const RAW_BYTE_LEN: usize = Extend::RAW_BYTE_LEN + u16::RAW_BYTE_LEN;
}

/// [VarColorLine](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#color-references-colorstop-and-colorline) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct VarColorLineMarker {
    color_stops_byte_len: usize,
}

impl VarColorLineMarker {
    pub fn extend_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + Extend::RAW_BYTE_LEN
    }

    pub fn num_stops_byte_range(&self) -> Range<usize> {
        let start = self.extend_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn color_stops_byte_range(&self) -> Range<usize> {
        let start = self.num_stops_byte_range().end;
        start..start + self.color_stops_byte_len
    }
}

impl MinByteRange for VarColorLineMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.color_stops_byte_range().end
    }
}

impl<'a> FontRead<'a> for VarColorLine<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a VarColorLineFixedFields = cursor.read_ref()?;
        let num_stops = fixed_fields.num_stops.get();
        let color_stops_byte_len = (num_stops as usize)
            .checked_mul(VarColorStop::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(color_stops_byte_len);
        cursor.finish(
            VarColorLineMarker {
                color_stops_byte_len,
            },
            fixed_fields,
        )
    }
}

/// [VarColorLine](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#color-references-colorstop-and-colorline) table
pub type VarColorLine<'a> = TableRef<'a, VarColorLineMarker, VarColorLineFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> VarColorLine<'a> {
    /// An Extend enum value.
    #[inline]
    pub fn extend(&self) -> Extend {
        self.fixed_fields().extend.get()
    }

    /// Number of ColorStop records.
    #[inline]
    pub fn num_stops(&self) -> u16 {
        self.fixed_fields().num_stops.get()
    }

    /// Allows for variations.
    #[inline]
    pub fn color_stops(&self) -> &'a [VarColorStop] {
        let range = self.shape.color_stops_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for VarColorLine<'a> {
    fn type_name(&self) -> &str {
        "VarColorLine"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("extend", self.extend())),
            1usize => Some(Field::new("num_stops", self.num_stops())),
            2usize => Some(Field::new(
                "color_stops",
                traversal::FieldType::array_of_records(
                    stringify!(VarColorStop),
                    self.color_stops(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for VarColorLine<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [Extend](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#color-references-colorstop-and-colorline) enumeration
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[repr(u8)]
#[allow(clippy::manual_non_exhaustive)]
pub enum Extend {
    #[default]
    Pad = 0,
    Repeat = 1,
    Reflect = 2,
    #[doc(hidden)]
    /// If font data is malformed we will map unknown values to this variant
    Unknown,
}

impl Extend {
    /// Create from a raw scalar.
    ///
    /// This will never fail; unknown values will be mapped to the `Unknown` variant
    pub fn new(raw: u8) -> Self {
        match raw {
            0 => Self::Pad,
            1 => Self::Repeat,
            2 => Self::Reflect,
            _ => Self::Unknown,
        }
    }
}

impl font_types::Scalar for Extend {
    type Raw = <u8 as font_types::Scalar>::Raw;
    fn to_raw(self) -> Self::Raw {
        (self as u8).to_raw()
    }
    fn from_raw(raw: Self::Raw) -> Self {
        let t = <u8>::from_raw(raw);
        Self::new(t)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> From<Extend> for FieldType<'a> {
    fn from(src: Extend) -> FieldType<'a> {
        (src as u8).into()
    }
}

/// [Paint](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#paint-tables) tables
#[derive(Clone)]
pub enum Paint<'a> {
    ColrLayers(PaintColrLayers<'a>),
    Solid(PaintSolid<'a>),
    VarSolid(PaintVarSolid<'a>),
    LinearGradient(PaintLinearGradient<'a>),
    VarLinearGradient(PaintVarLinearGradient<'a>),
    RadialGradient(PaintRadialGradient<'a>),
    VarRadialGradient(PaintVarRadialGradient<'a>),
    SweepGradient(PaintSweepGradient<'a>),
    VarSweepGradient(PaintVarSweepGradient<'a>),
    Glyph(PaintGlyph<'a>),
    ColrGlyph(PaintColrGlyph<'a>),
    Transform(PaintTransform<'a>),
    VarTransform(PaintVarTransform<'a>),
    Translate(PaintTranslate<'a>),
    VarTranslate(PaintVarTranslate<'a>),
    Scale(PaintScale<'a>),
    VarScale(PaintVarScale<'a>),
    ScaleAroundCenter(PaintScaleAroundCenter<'a>),
    VarScaleAroundCenter(PaintVarScaleAroundCenter<'a>),
    ScaleUniform(PaintScaleUniform<'a>),
    VarScaleUniform(PaintVarScaleUniform<'a>),
    ScaleUniformAroundCenter(PaintScaleUniformAroundCenter<'a>),
    VarScaleUniformAroundCenter(PaintVarScaleUniformAroundCenter<'a>),
    Rotate(PaintRotate<'a>),
    VarRotate(PaintVarRotate<'a>),
    RotateAroundCenter(PaintRotateAroundCenter<'a>),
    VarRotateAroundCenter(PaintVarRotateAroundCenter<'a>),
    Skew(PaintSkew<'a>),
    VarSkew(PaintVarSkew<'a>),
    SkewAroundCenter(PaintSkewAroundCenter<'a>),
    VarSkewAroundCenter(PaintVarSkewAroundCenter<'a>),
    Composite(PaintComposite<'a>),
}

impl<'a> Paint<'a> {
    ///Return the `FontData` used to resolve offsets for this table.
    #[inline]
    pub fn offset_data(&self) -> FontData<'a> {
        match self {
            Self::ColrLayers(item) => item.offset_data(),
            Self::Solid(item) => item.offset_data(),
            Self::VarSolid(item) => item.offset_data(),
            Self::LinearGradient(item) => item.offset_data(),
            Self::VarLinearGradient(item) => item.offset_data(),
            Self::RadialGradient(item) => item.offset_data(),
            Self::VarRadialGradient(item) => item.offset_data(),
            Self::SweepGradient(item) => item.offset_data(),
            Self::VarSweepGradient(item) => item.offset_data(),
            Self::Glyph(item) => item.offset_data(),
            Self::ColrGlyph(item) => item.offset_data(),
            Self::Transform(item) => item.offset_data(),
            Self::VarTransform(item) => item.offset_data(),
            Self::Translate(item) => item.offset_data(),
            Self::VarTranslate(item) => item.offset_data(),
            Self::Scale(item) => item.offset_data(),
            Self::VarScale(item) => item.offset_data(),
            Self::ScaleAroundCenter(item) => item.offset_data(),
            Self::VarScaleAroundCenter(item) => item.offset_data(),
            Self::ScaleUniform(item) => item.offset_data(),
            Self::VarScaleUniform(item) => item.offset_data(),
            Self::ScaleUniformAroundCenter(item) => item.offset_data(),
            Self::VarScaleUniformAroundCenter(item) => item.offset_data(),
            Self::Rotate(item) => item.offset_data(),
            Self::VarRotate(item) => item.offset_data(),
            Self::RotateAroundCenter(item) => item.offset_data(),
            Self::VarRotateAroundCenter(item) => item.offset_data(),
            Self::Skew(item) => item.offset_data(),
            Self::VarSkew(item) => item.offset_data(),
            Self::SkewAroundCenter(item) => item.offset_data(),
            Self::VarSkewAroundCenter(item) => item.offset_data(),
            Self::Composite(item) => item.offset_data(),
        }
    }

    /// Set to 1.
    #[inline]
    pub fn format(&self) -> u8 {
        match self {
            Self::ColrLayers(item) => item.format(),
            Self::Solid(item) => item.format(),
            Self::VarSolid(item) => item.format(),
            Self::LinearGradient(item) => item.format(),
            Self::VarLinearGradient(item) => item.format(),
            Self::RadialGradient(item) => item.format(),
            Self::VarRadialGradient(item) => item.format(),
            Self::SweepGradient(item) => item.format(),
            Self::VarSweepGradient(item) => item.format(),
            Self::Glyph(item) => item.format(),
            Self::ColrGlyph(item) => item.format(),
            Self::Transform(item) => item.format(),
            Self::VarTransform(item) => item.format(),
            Self::Translate(item) => item.format(),
            Self::VarTranslate(item) => item.format(),
            Self::Scale(item) => item.format(),
            Self::VarScale(item) => item.format(),
            Self::ScaleAroundCenter(item) => item.format(),
            Self::VarScaleAroundCenter(item) => item.format(),
            Self::ScaleUniform(item) => item.format(),
            Self::VarScaleUniform(item) => item.format(),
            Self::ScaleUniformAroundCenter(item) => item.format(),
            Self::VarScaleUniformAroundCenter(item) => item.format(),
            Self::Rotate(item) => item.format(),
            Self::VarRotate(item) => item.format(),
            Self::RotateAroundCenter(item) => item.format(),
            Self::VarRotateAroundCenter(item) => item.format(),
            Self::Skew(item) => item.format(),
            Self::VarSkew(item) => item.format(),
            Self::SkewAroundCenter(item) => item.format(),
            Self::VarSkewAroundCenter(item) => item.format(),
            Self::Composite(item) => item.format(),
        }
    }
}

impl<'a> FontRead<'a> for Paint<'a> {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let format: u8 = data.read_at(0usize)?;
        match format {
            PaintColrLayersMarker::FORMAT => Ok(Self::ColrLayers(FontRead::read(data)?)),
            PaintSolidMarker::FORMAT => Ok(Self::Solid(FontRead::read(data)?)),
            PaintVarSolidMarker::FORMAT => Ok(Self::VarSolid(FontRead::read(data)?)),
            PaintLinearGradientMarker::FORMAT => Ok(Self::LinearGradient(FontRead::read(data)?)),
            PaintVarLinearGradientMarker::FORMAT => {
                Ok(Self::VarLinearGradient(FontRead::read(data)?))
            }
            PaintRadialGradientMarker::FORMAT => Ok(Self::RadialGradient(FontRead::read(data)?)),
            PaintVarRadialGradientMarker::FORMAT => {
                Ok(Self::VarRadialGradient(FontRead::read(data)?))
            }
            PaintSweepGradientMarker::FORMAT => Ok(Self::SweepGradient(FontRead::read(data)?)),
            PaintVarSweepGradientMarker::FORMAT => {
                Ok(Self::VarSweepGradient(FontRead::read(data)?))
            }
            PaintGlyphMarker::FORMAT => Ok(Self::Glyph(FontRead::read(data)?)),
            PaintColrGlyphMarker::FORMAT => Ok(Self::ColrGlyph(FontRead::read(data)?)),
            PaintTransformMarker::FORMAT => Ok(Self::Transform(FontRead::read(data)?)),
            PaintVarTransformMarker::FORMAT => Ok(Self::VarTransform(FontRead::read(data)?)),
            PaintTranslateMarker::FORMAT => Ok(Self::Translate(FontRead::read(data)?)),
            PaintVarTranslateMarker::FORMAT => Ok(Self::VarTranslate(FontRead::read(data)?)),
            PaintScaleMarker::FORMAT => Ok(Self::Scale(FontRead::read(data)?)),
            PaintVarScaleMarker::FORMAT => Ok(Self::VarScale(FontRead::read(data)?)),
            PaintScaleAroundCenterMarker::FORMAT => {
                Ok(Self::ScaleAroundCenter(FontRead::read(data)?))
            }
            PaintVarScaleAroundCenterMarker::FORMAT => {
                Ok(Self::VarScaleAroundCenter(FontRead::read(data)?))
            }
            PaintScaleUniformMarker::FORMAT => Ok(Self::ScaleUniform(FontRead::read(data)?)),
            PaintVarScaleUniformMarker::FORMAT => Ok(Self::VarScaleUniform(FontRead::read(data)?)),
            PaintScaleUniformAroundCenterMarker::FORMAT => {
                Ok(Self::ScaleUniformAroundCenter(FontRead::read(data)?))
            }
            PaintVarScaleUniformAroundCenterMarker::FORMAT => {
                Ok(Self::VarScaleUniformAroundCenter(FontRead::read(data)?))
            }
            PaintRotateMarker::FORMAT => Ok(Self::Rotate(FontRead::read(data)?)),
            PaintVarRotateMarker::FORMAT => Ok(Self::VarRotate(FontRead::read(data)?)),
            PaintRotateAroundCenterMarker::FORMAT => {
                Ok(Self::RotateAroundCenter(FontRead::read(data)?))
            }
            PaintVarRotateAroundCenterMarker::FORMAT => {
                Ok(Self::VarRotateAroundCenter(FontRead::read(data)?))
            }
            PaintSkewMarker::FORMAT => Ok(Self::Skew(FontRead::read(data)?)),
            PaintVarSkewMarker::FORMAT => Ok(Self::VarSkew(FontRead::read(data)?)),
            PaintSkewAroundCenterMarker::FORMAT => {
                Ok(Self::SkewAroundCenter(FontRead::read(data)?))
            }
            PaintVarSkewAroundCenterMarker::FORMAT => {
                Ok(Self::VarSkewAroundCenter(FontRead::read(data)?))
            }
            PaintCompositeMarker::FORMAT => Ok(Self::Composite(FontRead::read(data)?)),
            other => Err(ReadError::InvalidFormat(other.into())),
        }
    }
}

impl MinByteRange for Paint<'_> {
    fn min_byte_range(&self) -> Range<usize> {
        match self {
            Self::ColrLayers(item) => item.min_byte_range(),
            Self::Solid(item) => item.min_byte_range(),
            Self::VarSolid(item) => item.min_byte_range(),
            Self::LinearGradient(item) => item.min_byte_range(),
            Self::VarLinearGradient(item) => item.min_byte_range(),
            Self::RadialGradient(item) => item.min_byte_range(),
            Self::VarRadialGradient(item) => item.min_byte_range(),
            Self::SweepGradient(item) => item.min_byte_range(),
            Self::VarSweepGradient(item) => item.min_byte_range(),
            Self::Glyph(item) => item.min_byte_range(),
            Self::ColrGlyph(item) => item.min_byte_range(),
            Self::Transform(item) => item.min_byte_range(),
            Self::VarTransform(item) => item.min_byte_range(),
            Self::Translate(item) => item.min_byte_range(),
            Self::VarTranslate(item) => item.min_byte_range(),
            Self::Scale(item) => item.min_byte_range(),
            Self::VarScale(item) => item.min_byte_range(),
            Self::ScaleAroundCenter(item) => item.min_byte_range(),
            Self::VarScaleAroundCenter(item) => item.min_byte_range(),
            Self::ScaleUniform(item) => item.min_byte_range(),
            Self::VarScaleUniform(item) => item.min_byte_range(),
            Self::ScaleUniformAroundCenter(item) => item.min_byte_range(),
            Self::VarScaleUniformAroundCenter(item) => item.min_byte_range(),
            Self::Rotate(item) => item.min_byte_range(),
            Self::VarRotate(item) => item.min_byte_range(),
            Self::RotateAroundCenter(item) => item.min_byte_range(),
            Self::VarRotateAroundCenter(item) => item.min_byte_range(),
            Self::Skew(item) => item.min_byte_range(),
            Self::VarSkew(item) => item.min_byte_range(),
            Self::SkewAroundCenter(item) => item.min_byte_range(),
            Self::VarSkewAroundCenter(item) => item.min_byte_range(),
            Self::Composite(item) => item.min_byte_range(),
        }
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> Paint<'a> {
    fn dyn_inner<'b>(&'b self) -> &'b dyn SomeTable<'a> {
        match self {
            Self::ColrLayers(table) => table,
            Self::Solid(table) => table,
            Self::VarSolid(table) => table,
            Self::LinearGradient(table) => table,
            Self::VarLinearGradient(table) => table,
            Self::RadialGradient(table) => table,
            Self::VarRadialGradient(table) => table,
            Self::SweepGradient(table) => table,
            Self::VarSweepGradient(table) => table,
            Self::Glyph(table) => table,
            Self::ColrGlyph(table) => table,
            Self::Transform(table) => table,
            Self::VarTransform(table) => table,
            Self::Translate(table) => table,
            Self::VarTranslate(table) => table,
            Self::Scale(table) => table,
            Self::VarScale(table) => table,
            Self::ScaleAroundCenter(table) => table,
            Self::VarScaleAroundCenter(table) => table,
            Self::ScaleUniform(table) => table,
            Self::VarScaleUniform(table) => table,
            Self::ScaleUniformAroundCenter(table) => table,
            Self::VarScaleUniformAroundCenter(table) => table,
            Self::Rotate(table) => table,
            Self::VarRotate(table) => table,
            Self::RotateAroundCenter(table) => table,
            Self::VarRotateAroundCenter(table) => table,
            Self::Skew(table) => table,
            Self::VarSkew(table) => table,
            Self::SkewAroundCenter(table) => table,
            Self::VarSkewAroundCenter(table) => table,
            Self::Composite(table) => table,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
impl std::fmt::Debug for Paint<'_> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        self.dyn_inner().fmt(f)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for Paint<'a> {
    fn type_name(&self) -> &str {
        self.dyn_inner().type_name()
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        self.dyn_inner().get_field(idx)
    }
}

impl Format<u8> for PaintColrLayersMarker {
    const FORMAT: u8 = 1;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintColrLayersFixedFields {
    pub format: u8,
    pub num_layers: u8,
    pub first_layer_index: BigEndian<u32>,
}

impl FixedSize for PaintColrLayersFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN + u8::RAW_BYTE_LEN + u32::RAW_BYTE_LEN;
}

/// [PaintColrLayers](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#format-1-paintcolrlayers) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintColrLayersMarker {}

impl PaintColrLayersMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn num_layers_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn first_layer_index_byte_range(&self) -> Range<usize> {
        let start = self.num_layers_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintColrLayersMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.first_layer_index_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintColrLayers<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintColrLayersFixedFields = cursor.read_ref()?;
        cursor.finish(PaintColrLayersMarker {}, fixed_fields)
    }
}

/// [PaintColrLayers](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#format-1-paintcolrlayers) table
pub type PaintColrLayers<'a> = TableRef<'a, PaintColrLayersMarker, PaintColrLayersFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintColrLayers<'a> {
    /// Set to 1.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Number of offsets to paint tables to read from LayerList.
    #[inline]
    pub fn num_layers(&self) -> u8 {
        self.fixed_fields().num_layers
    }

    /// Index (base 0) into the LayerList.
    #[inline]
    pub fn first_layer_index(&self) -> u32 {
        self.fixed_fields().first_layer_index.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintColrLayers<'a> {
    fn type_name(&self) -> &str {
        "PaintColrLayers"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new("num_layers", self.num_layers())),
            2usize => Some(Field::new("first_layer_index", self.first_layer_index())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintColrLayers<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintSolidMarker {
    const FORMAT: u8 = 2;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintSolidFixedFields {
    pub format: u8,
    pub palette_index: BigEndian<u16>,
    pub alpha: BigEndian<F2Dot14>,
}

impl FixedSize for PaintSolidFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN + u16::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN;
}

/// [PaintSolid](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-2-and-3-paintsolid-paintvarsolid) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintSolidMarker {}

impl PaintSolidMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn palette_index_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn alpha_byte_range(&self) -> Range<usize> {
        let start = self.palette_index_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintSolidMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.alpha_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintSolid<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintSolidFixedFields = cursor.read_ref()?;
        cursor.finish(PaintSolidMarker {}, fixed_fields)
    }
}

/// [PaintSolid](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-2-and-3-paintsolid-paintvarsolid) table
pub type PaintSolid<'a> = TableRef<'a, PaintSolidMarker, PaintSolidFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintSolid<'a> {
    /// Set to 2.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Index for a CPAL palette entry.
    #[inline]
    pub fn palette_index(&self) -> u16 {
        self.fixed_fields().palette_index.get()
    }

    /// Alpha value.
    #[inline]
    pub fn alpha(&self) -> F2Dot14 {
        self.fixed_fields().alpha.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintSolid<'a> {
    fn type_name(&self) -> &str {
        "PaintSolid"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new("palette_index", self.palette_index())),
            2usize => Some(Field::new("alpha", self.alpha())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintSolid<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarSolidMarker {
    const FORMAT: u8 = 3;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarSolidFixedFields {
    pub format: u8,
    pub palette_index: BigEndian<u16>,
    pub alpha: BigEndian<F2Dot14>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarSolidFixedFields {
    const RAW_BYTE_LEN: usize =
        u8::RAW_BYTE_LEN + u16::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN + u32::RAW_BYTE_LEN;
}

/// [PaintVarSolid](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-2-and-3-paintsolid-paintvarsolid) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarSolidMarker {}

impl PaintVarSolidMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn palette_index_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn alpha_byte_range(&self) -> Range<usize> {
        let start = self.palette_index_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.alpha_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarSolidMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarSolid<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarSolidFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarSolidMarker {}, fixed_fields)
    }
}

/// [PaintVarSolid](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-2-and-3-paintsolid-paintvarsolid) table
pub type PaintVarSolid<'a> = TableRef<'a, PaintVarSolidMarker, PaintVarSolidFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarSolid<'a> {
    /// Set to 3.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Index for a CPAL palette entry.
    #[inline]
    pub fn palette_index(&self) -> u16 {
        self.fixed_fields().palette_index.get()
    }

    /// Alpha value. For variation, use varIndexBase + 0.
    #[inline]
    pub fn alpha(&self) -> F2Dot14 {
        self.fixed_fields().alpha.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarSolid<'a> {
    fn type_name(&self) -> &str {
        "PaintVarSolid"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new("palette_index", self.palette_index())),
            2usize => Some(Field::new("alpha", self.alpha())),
            3usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarSolid<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintLinearGradientMarker {
    const FORMAT: u8 = 4;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintLinearGradientFixedFields {
    pub format: u8,
    pub color_line_offset: BigEndian<Offset24>,
    pub x0: BigEndian<FWord>,
    pub y0: BigEndian<FWord>,
    pub x1: BigEndian<FWord>,
    pub y1: BigEndian<FWord>,
    pub x2: BigEndian<FWord>,
    pub y2: BigEndian<FWord>,
}

impl FixedSize for PaintLinearGradientFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN;
}

/// [PaintLinearGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-4-and-5-paintlineargradient-paintvarlineargradient) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintLinearGradientMarker {}

impl PaintLinearGradientMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn color_line_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn x0_byte_range(&self) -> Range<usize> {
        let start = self.color_line_offset_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y0_byte_range(&self) -> Range<usize> {
        let start = self.x0_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn x1_byte_range(&self) -> Range<usize> {
        let start = self.y0_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y1_byte_range(&self) -> Range<usize> {
        let start = self.x1_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn x2_byte_range(&self) -> Range<usize> {
        let start = self.y1_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y2_byte_range(&self) -> Range<usize> {
        let start = self.x2_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintLinearGradientMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.y2_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintLinearGradient<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintLinearGradientFixedFields = cursor.read_ref()?;
        cursor.finish(PaintLinearGradientMarker {}, fixed_fields)
    }
}

/// [PaintLinearGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-4-and-5-paintlineargradient-paintvarlineargradient) table
pub type PaintLinearGradient<'a> =
    TableRef<'a, PaintLinearGradientMarker, PaintLinearGradientFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintLinearGradient<'a> {
    /// Set to 4.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to ColorLine table.
    #[inline]
    pub fn color_line_offset(&self) -> Offset24 {
        self.fixed_fields().color_line_offset.get()
    }

    /// Attempt to resolve [`color_line_offset`][Self::color_line_offset].
    #[inline]
    pub fn color_line(&self) -> Result<ColorLine<'a>, ReadError> {
        let data = self.data;
        self.color_line_offset().resolve(data)
    }

    /// Start point (p) x coordinate.
    #[inline]
    pub fn x0(&self) -> FWord {
        self.fixed_fields().x0.get()
    }

    /// Start point (p) y coordinate.
    #[inline]
    pub fn y0(&self) -> FWord {
        self.fixed_fields().y0.get()
    }

    /// End point (p) x coordinate.
    #[inline]
    pub fn x1(&self) -> FWord {
        self.fixed_fields().x1.get()
    }

    /// End point (p) y coordinate.
    #[inline]
    pub fn y1(&self) -> FWord {
        self.fixed_fields().y1.get()
    }

    /// Rotation point (p) x coordinate.
    #[inline]
    pub fn x2(&self) -> FWord {
        self.fixed_fields().x2.get()
    }

    /// Rotation point (p) y coordinate.
    #[inline]
    pub fn y2(&self) -> FWord {
        self.fixed_fields().y2.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintLinearGradient<'a> {
    fn type_name(&self) -> &str {
        "PaintLinearGradient"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "color_line_offset",
                FieldType::offset(self.color_line_offset(), self.color_line()),
            )),
            2usize => Some(Field::new("x0", self.x0())),
            3usize => Some(Field::new("y0", self.y0())),
            4usize => Some(Field::new("x1", self.x1())),
            5usize => Some(Field::new("y1", self.y1())),
            6usize => Some(Field::new("x2", self.x2())),
            7usize => Some(Field::new("y2", self.y2())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintLinearGradient<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarLinearGradientMarker {
    const FORMAT: u8 = 5;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarLinearGradientFixedFields {
    pub format: u8,
    pub color_line_offset: BigEndian<Offset24>,
    pub x0: BigEndian<FWord>,
    pub y0: BigEndian<FWord>,
    pub x1: BigEndian<FWord>,
    pub y1: BigEndian<FWord>,
    pub x2: BigEndian<FWord>,
    pub y2: BigEndian<FWord>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarLinearGradientFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [PaintVarLinearGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-4-and-5-paintlineargradient-paintvarlineargradient) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarLinearGradientMarker {}

impl PaintVarLinearGradientMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn color_line_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn x0_byte_range(&self) -> Range<usize> {
        let start = self.color_line_offset_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y0_byte_range(&self) -> Range<usize> {
        let start = self.x0_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn x1_byte_range(&self) -> Range<usize> {
        let start = self.y0_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y1_byte_range(&self) -> Range<usize> {
        let start = self.x1_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn x2_byte_range(&self) -> Range<usize> {
        let start = self.y1_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y2_byte_range(&self) -> Range<usize> {
        let start = self.x2_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.y2_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarLinearGradientMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarLinearGradient<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarLinearGradientFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarLinearGradientMarker {}, fixed_fields)
    }
}

/// [PaintVarLinearGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-4-and-5-paintlineargradient-paintvarlineargradient) table
pub type PaintVarLinearGradient<'a> =
    TableRef<'a, PaintVarLinearGradientMarker, PaintVarLinearGradientFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarLinearGradient<'a> {
    /// Set to 5.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to VarColorLine table.
    #[inline]
    pub fn color_line_offset(&self) -> Offset24 {
        self.fixed_fields().color_line_offset.get()
    }

    /// Attempt to resolve [`color_line_offset`][Self::color_line_offset].
    #[inline]
    pub fn color_line(&self) -> Result<VarColorLine<'a>, ReadError> {
        let data = self.data;
        self.color_line_offset().resolve(data)
    }

    /// Start point (p) x coordinate. For variation, use
    /// varIndexBase + 0.
    #[inline]
    pub fn x0(&self) -> FWord {
        self.fixed_fields().x0.get()
    }

    /// Start point (p) y coordinate. For variation, use
    /// varIndexBase + 1.
    #[inline]
    pub fn y0(&self) -> FWord {
        self.fixed_fields().y0.get()
    }

    /// End point (p) x coordinate. For variation, use varIndexBase
    /// + 2.
    #[inline]
    pub fn x1(&self) -> FWord {
        self.fixed_fields().x1.get()
    }

    /// End point (p) y coordinate. For variation, use varIndexBase
    /// + 3.
    #[inline]
    pub fn y1(&self) -> FWord {
        self.fixed_fields().y1.get()
    }

    /// Rotation point (p) x coordinate. For variation, use
    /// varIndexBase + 4.
    #[inline]
    pub fn x2(&self) -> FWord {
        self.fixed_fields().x2.get()
    }

    /// Rotation point (p) y coordinate. For variation, use
    /// varIndexBase + 5.
    #[inline]
    pub fn y2(&self) -> FWord {
        self.fixed_fields().y2.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarLinearGradient<'a> {
    fn type_name(&self) -> &str {
        "PaintVarLinearGradient"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "color_line_offset",
                FieldType::offset(self.color_line_offset(), self.color_line()),
            )),
            2usize => Some(Field::new("x0", self.x0())),
            3usize => Some(Field::new("y0", self.y0())),
            4usize => Some(Field::new("x1", self.x1())),
            5usize => Some(Field::new("y1", self.y1())),
            6usize => Some(Field::new("x2", self.x2())),
            7usize => Some(Field::new("y2", self.y2())),
            8usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarLinearGradient<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintRadialGradientMarker {
    const FORMAT: u8 = 6;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintRadialGradientFixedFields {
    pub format: u8,
    pub color_line_offset: BigEndian<Offset24>,
    pub x0: BigEndian<FWord>,
    pub y0: BigEndian<FWord>,
    pub radius0: BigEndian<UfWord>,
    pub x1: BigEndian<FWord>,
    pub y1: BigEndian<FWord>,
    pub radius1: BigEndian<UfWord>,
}

impl FixedSize for PaintRadialGradientFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + UfWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + UfWord::RAW_BYTE_LEN;
}

/// [PaintRadialGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-6-and-7-paintradialgradient-paintvarradialgradient) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintRadialGradientMarker {}

impl PaintRadialGradientMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn color_line_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn x0_byte_range(&self) -> Range<usize> {
        let start = self.color_line_offset_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y0_byte_range(&self) -> Range<usize> {
        let start = self.x0_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn radius0_byte_range(&self) -> Range<usize> {
        let start = self.y0_byte_range().end;
        start..start + UfWord::RAW_BYTE_LEN
    }

    pub fn x1_byte_range(&self) -> Range<usize> {
        let start = self.radius0_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y1_byte_range(&self) -> Range<usize> {
        let start = self.x1_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn radius1_byte_range(&self) -> Range<usize> {
        let start = self.y1_byte_range().end;
        start..start + UfWord::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintRadialGradientMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.radius1_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintRadialGradient<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintRadialGradientFixedFields = cursor.read_ref()?;
        cursor.finish(PaintRadialGradientMarker {}, fixed_fields)
    }
}

/// [PaintRadialGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-6-and-7-paintradialgradient-paintvarradialgradient) table
pub type PaintRadialGradient<'a> =
    TableRef<'a, PaintRadialGradientMarker, PaintRadialGradientFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintRadialGradient<'a> {
    /// Set to 6.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to ColorLine table.
    #[inline]
    pub fn color_line_offset(&self) -> Offset24 {
        self.fixed_fields().color_line_offset.get()
    }

    /// Attempt to resolve [`color_line_offset`][Self::color_line_offset].
    #[inline]
    pub fn color_line(&self) -> Result<ColorLine<'a>, ReadError> {
        let data = self.data;
        self.color_line_offset().resolve(data)
    }

    /// Start circle center x coordinate.
    #[inline]
    pub fn x0(&self) -> FWord {
        self.fixed_fields().x0.get()
    }

    /// Start circle center y coordinate.
    #[inline]
    pub fn y0(&self) -> FWord {
        self.fixed_fields().y0.get()
    }

    /// Start circle radius.
    #[inline]
    pub fn radius0(&self) -> UfWord {
        self.fixed_fields().radius0.get()
    }

    /// End circle center x coordinate.
    #[inline]
    pub fn x1(&self) -> FWord {
        self.fixed_fields().x1.get()
    }

    /// End circle center y coordinate.
    #[inline]
    pub fn y1(&self) -> FWord {
        self.fixed_fields().y1.get()
    }

    /// End circle radius.
    #[inline]
    pub fn radius1(&self) -> UfWord {
        self.fixed_fields().radius1.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintRadialGradient<'a> {
    fn type_name(&self) -> &str {
        "PaintRadialGradient"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "color_line_offset",
                FieldType::offset(self.color_line_offset(), self.color_line()),
            )),
            2usize => Some(Field::new("x0", self.x0())),
            3usize => Some(Field::new("y0", self.y0())),
            4usize => Some(Field::new("radius0", self.radius0())),
            5usize => Some(Field::new("x1", self.x1())),
            6usize => Some(Field::new("y1", self.y1())),
            7usize => Some(Field::new("radius1", self.radius1())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintRadialGradient<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarRadialGradientMarker {
    const FORMAT: u8 = 7;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarRadialGradientFixedFields {
    pub format: u8,
    pub color_line_offset: BigEndian<Offset24>,
    pub x0: BigEndian<FWord>,
    pub y0: BigEndian<FWord>,
    pub radius0: BigEndian<UfWord>,
    pub x1: BigEndian<FWord>,
    pub y1: BigEndian<FWord>,
    pub radius1: BigEndian<UfWord>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarRadialGradientFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + UfWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + UfWord::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [PaintVarRadialGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-6-and-7-paintradialgradient-paintvarradialgradient) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarRadialGradientMarker {}

impl PaintVarRadialGradientMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn color_line_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn x0_byte_range(&self) -> Range<usize> {
        let start = self.color_line_offset_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y0_byte_range(&self) -> Range<usize> {
        let start = self.x0_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn radius0_byte_range(&self) -> Range<usize> {
        let start = self.y0_byte_range().end;
        start..start + UfWord::RAW_BYTE_LEN
    }

    pub fn x1_byte_range(&self) -> Range<usize> {
        let start = self.radius0_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn y1_byte_range(&self) -> Range<usize> {
        let start = self.x1_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn radius1_byte_range(&self) -> Range<usize> {
        let start = self.y1_byte_range().end;
        start..start + UfWord::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.radius1_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarRadialGradientMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarRadialGradient<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarRadialGradientFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarRadialGradientMarker {}, fixed_fields)
    }
}

/// [PaintVarRadialGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-6-and-7-paintradialgradient-paintvarradialgradient) table
pub type PaintVarRadialGradient<'a> =
    TableRef<'a, PaintVarRadialGradientMarker, PaintVarRadialGradientFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarRadialGradient<'a> {
    /// Set to 7.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to VarColorLine table.
    #[inline]
    pub fn color_line_offset(&self) -> Offset24 {
        self.fixed_fields().color_line_offset.get()
    }

    /// Attempt to resolve [`color_line_offset`][Self::color_line_offset].
    #[inline]
    pub fn color_line(&self) -> Result<VarColorLine<'a>, ReadError> {
        let data = self.data;
        self.color_line_offset().resolve(data)
    }

    /// Start circle center x coordinate. For variation, use
    /// varIndexBase + 0.
    #[inline]
    pub fn x0(&self) -> FWord {
        self.fixed_fields().x0.get()
    }

    /// Start circle center y coordinate. For variation, use
    /// varIndexBase + 1.
    #[inline]
    pub fn y0(&self) -> FWord {
        self.fixed_fields().y0.get()
    }

    /// Start circle radius. For variation, use varIndexBase + 2.
    #[inline]
    pub fn radius0(&self) -> UfWord {
        self.fixed_fields().radius0.get()
    }

    /// End circle center x coordinate. For variation, use varIndexBase
    /// + 3.
    #[inline]
    pub fn x1(&self) -> FWord {
        self.fixed_fields().x1.get()
    }

    /// End circle center y coordinate. For variation, use varIndexBase
    /// + 4.
    #[inline]
    pub fn y1(&self) -> FWord {
        self.fixed_fields().y1.get()
    }

    /// End circle radius. For variation, use varIndexBase + 5.
    #[inline]
    pub fn radius1(&self) -> UfWord {
        self.fixed_fields().radius1.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarRadialGradient<'a> {
    fn type_name(&self) -> &str {
        "PaintVarRadialGradient"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "color_line_offset",
                FieldType::offset(self.color_line_offset(), self.color_line()),
            )),
            2usize => Some(Field::new("x0", self.x0())),
            3usize => Some(Field::new("y0", self.y0())),
            4usize => Some(Field::new("radius0", self.radius0())),
            5usize => Some(Field::new("x1", self.x1())),
            6usize => Some(Field::new("y1", self.y1())),
            7usize => Some(Field::new("radius1", self.radius1())),
            8usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarRadialGradient<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintSweepGradientMarker {
    const FORMAT: u8 = 8;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintSweepGradientFixedFields {
    pub format: u8,
    pub color_line_offset: BigEndian<Offset24>,
    pub center_x: BigEndian<FWord>,
    pub center_y: BigEndian<FWord>,
    pub start_angle: BigEndian<F2Dot14>,
    pub end_angle: BigEndian<F2Dot14>,
}

impl FixedSize for PaintSweepGradientFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN;
}

/// [PaintSweepGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-8-and-9-paintsweepgradient-paintvarsweepgradient) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintSweepGradientMarker {}

impl PaintSweepGradientMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn color_line_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn center_x_byte_range(&self) -> Range<usize> {
        let start = self.color_line_offset_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn center_y_byte_range(&self) -> Range<usize> {
        let start = self.center_x_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn start_angle_byte_range(&self) -> Range<usize> {
        let start = self.center_y_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn end_angle_byte_range(&self) -> Range<usize> {
        let start = self.start_angle_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintSweepGradientMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.end_angle_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintSweepGradient<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintSweepGradientFixedFields = cursor.read_ref()?;
        cursor.finish(PaintSweepGradientMarker {}, fixed_fields)
    }
}

/// [PaintSweepGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-8-and-9-paintsweepgradient-paintvarsweepgradient) table
pub type PaintSweepGradient<'a> =
    TableRef<'a, PaintSweepGradientMarker, PaintSweepGradientFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintSweepGradient<'a> {
    /// Set to 8.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to ColorLine table.
    #[inline]
    pub fn color_line_offset(&self) -> Offset24 {
        self.fixed_fields().color_line_offset.get()
    }

    /// Attempt to resolve [`color_line_offset`][Self::color_line_offset].
    #[inline]
    pub fn color_line(&self) -> Result<ColorLine<'a>, ReadError> {
        let data = self.data;
        self.color_line_offset().resolve(data)
    }

    /// Center x coordinate.
    #[inline]
    pub fn center_x(&self) -> FWord {
        self.fixed_fields().center_x.get()
    }

    /// Center y coordinate.
    #[inline]
    pub fn center_y(&self) -> FWord {
        self.fixed_fields().center_y.get()
    }

    /// Start of the angular range of the gradient, 180 in
    /// counter-clockwise degrees per 1.0 of value.
    #[inline]
    pub fn start_angle(&self) -> F2Dot14 {
        self.fixed_fields().start_angle.get()
    }

    /// End of the angular range of the gradient, 180 in
    /// counter-clockwise degrees per 1.0 of value.
    #[inline]
    pub fn end_angle(&self) -> F2Dot14 {
        self.fixed_fields().end_angle.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintSweepGradient<'a> {
    fn type_name(&self) -> &str {
        "PaintSweepGradient"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "color_line_offset",
                FieldType::offset(self.color_line_offset(), self.color_line()),
            )),
            2usize => Some(Field::new("center_x", self.center_x())),
            3usize => Some(Field::new("center_y", self.center_y())),
            4usize => Some(Field::new("start_angle", self.start_angle())),
            5usize => Some(Field::new("end_angle", self.end_angle())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintSweepGradient<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarSweepGradientMarker {
    const FORMAT: u8 = 9;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarSweepGradientFixedFields {
    pub format: u8,
    pub color_line_offset: BigEndian<Offset24>,
    pub center_x: BigEndian<FWord>,
    pub center_y: BigEndian<FWord>,
    pub start_angle: BigEndian<F2Dot14>,
    pub end_angle: BigEndian<F2Dot14>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarSweepGradientFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [PaintVarSweepGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-8-and-9-paintsweepgradient-paintvarsweepgradient) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarSweepGradientMarker {}

impl PaintVarSweepGradientMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn color_line_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn center_x_byte_range(&self) -> Range<usize> {
        let start = self.color_line_offset_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn center_y_byte_range(&self) -> Range<usize> {
        let start = self.center_x_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn start_angle_byte_range(&self) -> Range<usize> {
        let start = self.center_y_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn end_angle_byte_range(&self) -> Range<usize> {
        let start = self.start_angle_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.end_angle_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarSweepGradientMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarSweepGradient<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarSweepGradientFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarSweepGradientMarker {}, fixed_fields)
    }
}

/// [PaintVarSweepGradient](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-8-and-9-paintsweepgradient-paintvarsweepgradient) table
pub type PaintVarSweepGradient<'a> =
    TableRef<'a, PaintVarSweepGradientMarker, PaintVarSweepGradientFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarSweepGradient<'a> {
    /// Set to 9.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to VarColorLine table.
    #[inline]
    pub fn color_line_offset(&self) -> Offset24 {
        self.fixed_fields().color_line_offset.get()
    }

    /// Attempt to resolve [`color_line_offset`][Self::color_line_offset].
    #[inline]
    pub fn color_line(&self) -> Result<VarColorLine<'a>, ReadError> {
        let data = self.data;
        self.color_line_offset().resolve(data)
    }

    /// Center x coordinate. For variation, use varIndexBase + 0.
    #[inline]
    pub fn center_x(&self) -> FWord {
        self.fixed_fields().center_x.get()
    }

    /// Center y coordinate. For variation, use varIndexBase + 1.
    #[inline]
    pub fn center_y(&self) -> FWord {
        self.fixed_fields().center_y.get()
    }

    /// Start of the angular range of the gradient, 180 in
    /// counter-clockwise degrees per 1.0 of value. For variation, use
    /// varIndexBase + 2.
    #[inline]
    pub fn start_angle(&self) -> F2Dot14 {
        self.fixed_fields().start_angle.get()
    }

    /// End of the angular range of the gradient, 180 in
    /// counter-clockwise degrees per 1.0 of value. For variation, use
    /// varIndexBase + 3.
    #[inline]
    pub fn end_angle(&self) -> F2Dot14 {
        self.fixed_fields().end_angle.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarSweepGradient<'a> {
    fn type_name(&self) -> &str {
        "PaintVarSweepGradient"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "color_line_offset",
                FieldType::offset(self.color_line_offset(), self.color_line()),
            )),
            2usize => Some(Field::new("center_x", self.center_x())),
            3usize => Some(Field::new("center_y", self.center_y())),
            4usize => Some(Field::new("start_angle", self.start_angle())),
            5usize => Some(Field::new("end_angle", self.end_angle())),
            6usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarSweepGradient<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintGlyphMarker {
    const FORMAT: u8 = 10;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintGlyphFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub glyph_id: BigEndian<GlyphId16>,
}

impl FixedSize for PaintGlyphFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN + GlyphId16::RAW_BYTE_LEN;
}

/// [PaintGlyph](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#format-10-paintglyph) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintGlyphMarker {}

impl PaintGlyphMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn glyph_id_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + GlyphId16::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintGlyphMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.glyph_id_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintGlyph<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintGlyphFixedFields = cursor.read_ref()?;
        cursor.finish(PaintGlyphMarker {}, fixed_fields)
    }
}

/// [PaintGlyph](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#format-10-paintglyph) table
pub type PaintGlyph<'a> = TableRef<'a, PaintGlyphMarker, PaintGlyphFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintGlyph<'a> {
    /// Set to 10.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint table.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Glyph ID for the source outline.
    #[inline]
    pub fn glyph_id(&self) -> GlyphId16 {
        self.fixed_fields().glyph_id.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintGlyph<'a> {
    fn type_name(&self) -> &str {
        "PaintGlyph"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("glyph_id", self.glyph_id())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintGlyph<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintColrGlyphMarker {
    const FORMAT: u8 = 11;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintColrGlyphFixedFields {
    pub format: u8,
    pub glyph_id: BigEndian<GlyphId16>,
}

impl FixedSize for PaintColrGlyphFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN + GlyphId16::RAW_BYTE_LEN;
}

/// [PaintColrGlyph](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#format-11-paintcolrglyph) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintColrGlyphMarker {}

impl PaintColrGlyphMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn glyph_id_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + GlyphId16::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintColrGlyphMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.glyph_id_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintColrGlyph<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintColrGlyphFixedFields = cursor.read_ref()?;
        cursor.finish(PaintColrGlyphMarker {}, fixed_fields)
    }
}

/// [PaintColrGlyph](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#format-11-paintcolrglyph) table
pub type PaintColrGlyph<'a> = TableRef<'a, PaintColrGlyphMarker, PaintColrGlyphFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintColrGlyph<'a> {
    /// Set to 11.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Glyph ID for a BaseGlyphList base glyph.
    #[inline]
    pub fn glyph_id(&self) -> GlyphId16 {
        self.fixed_fields().glyph_id.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintColrGlyph<'a> {
    fn type_name(&self) -> &str {
        "PaintColrGlyph"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new("glyph_id", self.glyph_id())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintColrGlyph<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintTransformMarker {
    const FORMAT: u8 = 12;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintTransformFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub transform_offset: BigEndian<Offset24>,
}

impl FixedSize for PaintTransformFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN;
}

/// [PaintTransform](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-12-and-13-painttransform-paintvartransform) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintTransformMarker {}

impl PaintTransformMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn transform_offset_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintTransformMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.transform_offset_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintTransform<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintTransformFixedFields = cursor.read_ref()?;
        cursor.finish(PaintTransformMarker {}, fixed_fields)
    }
}

/// [PaintTransform](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-12-and-13-painttransform-paintvartransform) table
pub type PaintTransform<'a> = TableRef<'a, PaintTransformMarker, PaintTransformFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintTransform<'a> {
    /// Set to 12.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Offset to an Affine2x3 table.
    #[inline]
    pub fn transform_offset(&self) -> Offset24 {
        self.fixed_fields().transform_offset.get()
    }

    /// Attempt to resolve [`transform_offset`][Self::transform_offset].
    #[inline]
    pub fn transform(&self) -> Result<Affine2x3<'a>, ReadError> {
        let data = self.data;
        self.transform_offset().resolve(data)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintTransform<'a> {
    fn type_name(&self) -> &str {
        "PaintTransform"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new(
                "transform_offset",
                FieldType::offset(self.transform_offset(), self.transform()),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintTransform<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarTransformMarker {
    const FORMAT: u8 = 13;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarTransformFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub transform_offset: BigEndian<Offset24>,
}

impl FixedSize for PaintVarTransformFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN;
}

/// [PaintVarTransform](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-12-and-13-painttransform-paintvartransform) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarTransformMarker {}

impl PaintVarTransformMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn transform_offset_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarTransformMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.transform_offset_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarTransform<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarTransformFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarTransformMarker {}, fixed_fields)
    }
}

/// [PaintVarTransform](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-12-and-13-painttransform-paintvartransform) table
pub type PaintVarTransform<'a> =
    TableRef<'a, PaintVarTransformMarker, PaintVarTransformFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarTransform<'a> {
    /// Set to 13.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Offset to a VarAffine2x3 table.
    #[inline]
    pub fn transform_offset(&self) -> Offset24 {
        self.fixed_fields().transform_offset.get()
    }

    /// Attempt to resolve [`transform_offset`][Self::transform_offset].
    #[inline]
    pub fn transform(&self) -> Result<VarAffine2x3<'a>, ReadError> {
        let data = self.data;
        self.transform_offset().resolve(data)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarTransform<'a> {
    fn type_name(&self) -> &str {
        "PaintVarTransform"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new(
                "transform_offset",
                FieldType::offset(self.transform_offset(), self.transform()),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarTransform<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct Affine2x3FixedFields {
    pub xx: BigEndian<Fixed>,
    pub yx: BigEndian<Fixed>,
    pub xy: BigEndian<Fixed>,
    pub yy: BigEndian<Fixed>,
    pub dx: BigEndian<Fixed>,
    pub dy: BigEndian<Fixed>,
}

impl FixedSize for Affine2x3FixedFields {
    const RAW_BYTE_LEN: usize = Fixed::RAW_BYTE_LEN
        + Fixed::RAW_BYTE_LEN
        + Fixed::RAW_BYTE_LEN
        + Fixed::RAW_BYTE_LEN
        + Fixed::RAW_BYTE_LEN
        + Fixed::RAW_BYTE_LEN;
}

/// [Affine2x3](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-12-and-13-painttransform-paintvartransform) record
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct Affine2x3Marker {}

impl Affine2x3Marker {
    pub fn xx_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + Fixed::RAW_BYTE_LEN
    }

    pub fn yx_byte_range(&self) -> Range<usize> {
        let start = self.xx_byte_range().end;
        start..start + Fixed::RAW_BYTE_LEN
    }

    pub fn xy_byte_range(&self) -> Range<usize> {
        let start = self.yx_byte_range().end;
        start..start + Fixed::RAW_BYTE_LEN
    }

    pub fn yy_byte_range(&self) -> Range<usize> {
        let start = self.xy_byte_range().end;
        start..start + Fixed::RAW_BYTE_LEN
    }

    pub fn dx_byte_range(&self) -> Range<usize> {
        let start = self.yy_byte_range().end;
        start..start + Fixed::RAW_BYTE_LEN
    }

    pub fn dy_byte_range(&self) -> Range<usize> {
        let start = self.dx_byte_range().end;
        start..start + Fixed::RAW_BYTE_LEN
    }
}

impl MinByteRange for Affine2x3Marker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.dy_byte_range().end
    }
}

impl<'a> FontRead<'a> for Affine2x3<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a Affine2x3FixedFields = cursor.read_ref()?;
        cursor.finish(Affine2x3Marker {}, fixed_fields)
    }
}

/// [Affine2x3](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-12-and-13-painttransform-paintvartransform) record
pub type Affine2x3<'a> = TableRef<'a, Affine2x3Marker, Affine2x3FixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> Affine2x3<'a> {
    /// x-component of transformed x-basis vector.
    #[inline]
    pub fn xx(&self) -> Fixed {
        self.fixed_fields().xx.get()
    }

    /// y-component of transformed x-basis vector.
    #[inline]
    pub fn yx(&self) -> Fixed {
        self.fixed_fields().yx.get()
    }

    /// x-component of transformed y-basis vector.
    #[inline]
    pub fn xy(&self) -> Fixed {
        self.fixed_fields().xy.get()
    }

    /// y-component of transformed y-basis vector.
    #[inline]
    pub fn yy(&self) -> Fixed {
        self.fixed_fields().yy.get()
    }

    /// Translation in x direction.
    #[inline]
    pub fn dx(&self) -> Fixed {
        self.fixed_fields().dx.get()
    }

    /// Translation in y direction.
    #[inline]
    pub fn dy(&self) -> Fixed {
        self.fixed_fields().dy.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for Affine2x3<'a> {
    fn type_name(&self) -> &str {
        "Affine2x3"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("xx", self.xx())),
            1usize => Some(Field::new("yx", self.yx())),
            2usize => Some(Field::new("xy", self.xy())),
            3usize => Some(Field::new("yy", self.yy())),
            4usize => Some(Field::new("dx", self.dx())),
            5usize => Some(Field::new("dy", self.dy())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for Affine2x3<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct VarAffine2x3FixedFields {
    pub xx: BigEndian<Fixed>,
    pub yx: BigEndian<Fixed>,
    pub xy: BigEndian<Fixed>,
    pub yy: BigEndian<Fixed>,
    pub dx: BigEndian<Fixed>,
    pub dy: BigEndian<Fixed>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for VarAffine2x3FixedFields {
    const RAW_BYTE_LEN: usize = Fixed::RAW_BYTE_LEN
        + Fixed::RAW_BYTE_LEN
        + Fixed::RAW_BYTE_LEN
        + Fixed::RAW_BYTE_LEN
        + Fixed::RAW_BYTE_LEN
        + Fixed::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [VarAffine2x3](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-12-and-13-painttransform-paintvartransform) record
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct VarAffine2x3Marker {}

impl VarAffine2x3Marker {
    pub fn xx_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + Fixed::RAW_BYTE_LEN
    }

    pub fn yx_byte_range(&self) -> Range<usize> {
        let start = self.xx_byte_range().end;
        start..start + Fixed::RAW_BYTE_LEN
    }

    pub fn xy_byte_range(&self) -> Range<usize> {
        let start = self.yx_byte_range().end;
        start..start + Fixed::RAW_BYTE_LEN
    }

    pub fn yy_byte_range(&self) -> Range<usize> {
        let start = self.xy_byte_range().end;
        start..start + Fixed::RAW_BYTE_LEN
    }

    pub fn dx_byte_range(&self) -> Range<usize> {
        let start = self.yy_byte_range().end;
        start..start + Fixed::RAW_BYTE_LEN
    }

    pub fn dy_byte_range(&self) -> Range<usize> {
        let start = self.dx_byte_range().end;
        start..start + Fixed::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.dy_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for VarAffine2x3Marker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for VarAffine2x3<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a VarAffine2x3FixedFields = cursor.read_ref()?;
        cursor.finish(VarAffine2x3Marker {}, fixed_fields)
    }
}

/// [VarAffine2x3](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-12-and-13-painttransform-paintvartransform) record
pub type VarAffine2x3<'a> = TableRef<'a, VarAffine2x3Marker, VarAffine2x3FixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> VarAffine2x3<'a> {
    /// x-component of transformed x-basis vector. For variation, use
    /// varIndexBase + 0.
    #[inline]
    pub fn xx(&self) -> Fixed {
        self.fixed_fields().xx.get()
    }

    /// y-component of transformed x-basis vector. For variation, use
    /// varIndexBase + 1.
    #[inline]
    pub fn yx(&self) -> Fixed {
        self.fixed_fields().yx.get()
    }

    /// x-component of transformed y-basis vector. For variation, use
    /// varIndexBase + 2.
    #[inline]
    pub fn xy(&self) -> Fixed {
        self.fixed_fields().xy.get()
    }

    /// y-component of transformed y-basis vector. For variation, use
    /// varIndexBase + 3.
    #[inline]
    pub fn yy(&self) -> Fixed {
        self.fixed_fields().yy.get()
    }

    /// Translation in x direction. For variation, use varIndexBase + 4.
    #[inline]
    pub fn dx(&self) -> Fixed {
        self.fixed_fields().dx.get()
    }

    /// Translation in y direction. For variation, use varIndexBase + 5.
    #[inline]
    pub fn dy(&self) -> Fixed {
        self.fixed_fields().dy.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for VarAffine2x3<'a> {
    fn type_name(&self) -> &str {
        "VarAffine2x3"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("xx", self.xx())),
            1usize => Some(Field::new("yx", self.yx())),
            2usize => Some(Field::new("xy", self.xy())),
            3usize => Some(Field::new("yy", self.yy())),
            4usize => Some(Field::new("dx", self.dx())),
            5usize => Some(Field::new("dy", self.dy())),
            6usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for VarAffine2x3<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintTranslateMarker {
    const FORMAT: u8 = 14;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintTranslateFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub dx: BigEndian<FWord>,
    pub dy: BigEndian<FWord>,
}

impl FixedSize for PaintTranslateFixedFields {
    const RAW_BYTE_LEN: usize =
        u8::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN + FWord::RAW_BYTE_LEN + FWord::RAW_BYTE_LEN;
}

/// [PaintTranslate](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-14-and-15-painttranslate-paintvartranslate) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintTranslateMarker {}

impl PaintTranslateMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn dx_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn dy_byte_range(&self) -> Range<usize> {
        let start = self.dx_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintTranslateMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.dy_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintTranslate<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintTranslateFixedFields = cursor.read_ref()?;
        cursor.finish(PaintTranslateMarker {}, fixed_fields)
    }
}

/// [PaintTranslate](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-14-and-15-painttranslate-paintvartranslate) table
pub type PaintTranslate<'a> = TableRef<'a, PaintTranslateMarker, PaintTranslateFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintTranslate<'a> {
    /// Set to 14.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Translation in x direction.
    #[inline]
    pub fn dx(&self) -> FWord {
        self.fixed_fields().dx.get()
    }

    /// Translation in y direction.
    #[inline]
    pub fn dy(&self) -> FWord {
        self.fixed_fields().dy.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintTranslate<'a> {
    fn type_name(&self) -> &str {
        "PaintTranslate"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("dx", self.dx())),
            3usize => Some(Field::new("dy", self.dy())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintTranslate<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarTranslateMarker {
    const FORMAT: u8 = 15;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarTranslateFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub dx: BigEndian<FWord>,
    pub dy: BigEndian<FWord>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarTranslateFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [PaintVarTranslate](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-14-and-15-painttranslate-paintvartranslate) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarTranslateMarker {}

impl PaintVarTranslateMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn dx_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn dy_byte_range(&self) -> Range<usize> {
        let start = self.dx_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.dy_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarTranslateMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarTranslate<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarTranslateFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarTranslateMarker {}, fixed_fields)
    }
}

/// [PaintVarTranslate](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-14-and-15-painttranslate-paintvartranslate) table
pub type PaintVarTranslate<'a> =
    TableRef<'a, PaintVarTranslateMarker, PaintVarTranslateFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarTranslate<'a> {
    /// Set to 15.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Translation in x direction. For variation, use varIndexBase + 0.
    #[inline]
    pub fn dx(&self) -> FWord {
        self.fixed_fields().dx.get()
    }

    /// Translation in y direction. For variation, use varIndexBase + 1.
    #[inline]
    pub fn dy(&self) -> FWord {
        self.fixed_fields().dy.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarTranslate<'a> {
    fn type_name(&self) -> &str {
        "PaintVarTranslate"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("dx", self.dx())),
            3usize => Some(Field::new("dy", self.dy())),
            4usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarTranslate<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintScaleMarker {
    const FORMAT: u8 = 16;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintScaleFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub scale_x: BigEndian<F2Dot14>,
    pub scale_y: BigEndian<F2Dot14>,
}

impl FixedSize for PaintScaleFixedFields {
    const RAW_BYTE_LEN: usize =
        u8::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN;
}

/// [PaintScale](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintScaleMarker {}

impl PaintScaleMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn scale_x_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn scale_y_byte_range(&self) -> Range<usize> {
        let start = self.scale_x_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintScaleMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.scale_y_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintScale<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintScaleFixedFields = cursor.read_ref()?;
        cursor.finish(PaintScaleMarker {}, fixed_fields)
    }
}

/// [PaintScale](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
pub type PaintScale<'a> = TableRef<'a, PaintScaleMarker, PaintScaleFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintScale<'a> {
    /// Set to 16.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Scale factor in x direction.
    #[inline]
    pub fn scale_x(&self) -> F2Dot14 {
        self.fixed_fields().scale_x.get()
    }

    /// Scale factor in y direction.
    #[inline]
    pub fn scale_y(&self) -> F2Dot14 {
        self.fixed_fields().scale_y.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintScale<'a> {
    fn type_name(&self) -> &str {
        "PaintScale"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("scale_x", self.scale_x())),
            3usize => Some(Field::new("scale_y", self.scale_y())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintScale<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarScaleMarker {
    const FORMAT: u8 = 17;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarScaleFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub scale_x: BigEndian<F2Dot14>,
    pub scale_y: BigEndian<F2Dot14>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarScaleFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [PaintVarScale](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarScaleMarker {}

impl PaintVarScaleMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn scale_x_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn scale_y_byte_range(&self) -> Range<usize> {
        let start = self.scale_x_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.scale_y_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarScaleMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarScale<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarScaleFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarScaleMarker {}, fixed_fields)
    }
}

/// [PaintVarScale](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
pub type PaintVarScale<'a> = TableRef<'a, PaintVarScaleMarker, PaintVarScaleFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarScale<'a> {
    /// Set to 17.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Scale factor in x direction. For variation, use varIndexBase +
    /// 0.
    #[inline]
    pub fn scale_x(&self) -> F2Dot14 {
        self.fixed_fields().scale_x.get()
    }

    /// Scale factor in y direction. For variation, use varIndexBase +
    /// 1.
    #[inline]
    pub fn scale_y(&self) -> F2Dot14 {
        self.fixed_fields().scale_y.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarScale<'a> {
    fn type_name(&self) -> &str {
        "PaintVarScale"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("scale_x", self.scale_x())),
            3usize => Some(Field::new("scale_y", self.scale_y())),
            4usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarScale<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintScaleAroundCenterMarker {
    const FORMAT: u8 = 18;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintScaleAroundCenterFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub scale_x: BigEndian<F2Dot14>,
    pub scale_y: BigEndian<F2Dot14>,
    pub center_x: BigEndian<FWord>,
    pub center_y: BigEndian<FWord>,
}

impl FixedSize for PaintScaleAroundCenterFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN;
}

/// [PaintScaleAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintScaleAroundCenterMarker {}

impl PaintScaleAroundCenterMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn scale_x_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn scale_y_byte_range(&self) -> Range<usize> {
        let start = self.scale_x_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn center_x_byte_range(&self) -> Range<usize> {
        let start = self.scale_y_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn center_y_byte_range(&self) -> Range<usize> {
        let start = self.center_x_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintScaleAroundCenterMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.center_y_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintScaleAroundCenter<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintScaleAroundCenterFixedFields = cursor.read_ref()?;
        cursor.finish(PaintScaleAroundCenterMarker {}, fixed_fields)
    }
}

/// [PaintScaleAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
pub type PaintScaleAroundCenter<'a> =
    TableRef<'a, PaintScaleAroundCenterMarker, PaintScaleAroundCenterFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintScaleAroundCenter<'a> {
    /// Set to 18.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Scale factor in x direction.
    #[inline]
    pub fn scale_x(&self) -> F2Dot14 {
        self.fixed_fields().scale_x.get()
    }

    /// Scale factor in y direction.
    #[inline]
    pub fn scale_y(&self) -> F2Dot14 {
        self.fixed_fields().scale_y.get()
    }

    /// x coordinate for the center of scaling.
    #[inline]
    pub fn center_x(&self) -> FWord {
        self.fixed_fields().center_x.get()
    }

    /// y coordinate for the center of scaling.
    #[inline]
    pub fn center_y(&self) -> FWord {
        self.fixed_fields().center_y.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintScaleAroundCenter<'a> {
    fn type_name(&self) -> &str {
        "PaintScaleAroundCenter"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("scale_x", self.scale_x())),
            3usize => Some(Field::new("scale_y", self.scale_y())),
            4usize => Some(Field::new("center_x", self.center_x())),
            5usize => Some(Field::new("center_y", self.center_y())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintScaleAroundCenter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarScaleAroundCenterMarker {
    const FORMAT: u8 = 19;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarScaleAroundCenterFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub scale_x: BigEndian<F2Dot14>,
    pub scale_y: BigEndian<F2Dot14>,
    pub center_x: BigEndian<FWord>,
    pub center_y: BigEndian<FWord>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarScaleAroundCenterFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [PaintVarScaleAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarScaleAroundCenterMarker {}

impl PaintVarScaleAroundCenterMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn scale_x_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn scale_y_byte_range(&self) -> Range<usize> {
        let start = self.scale_x_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn center_x_byte_range(&self) -> Range<usize> {
        let start = self.scale_y_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn center_y_byte_range(&self) -> Range<usize> {
        let start = self.center_x_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.center_y_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarScaleAroundCenterMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarScaleAroundCenter<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarScaleAroundCenterFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarScaleAroundCenterMarker {}, fixed_fields)
    }
}

/// [PaintVarScaleAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
pub type PaintVarScaleAroundCenter<'a> =
    TableRef<'a, PaintVarScaleAroundCenterMarker, PaintVarScaleAroundCenterFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarScaleAroundCenter<'a> {
    /// Set to 19.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Scale factor in x direction. For variation, use varIndexBase +
    /// 0.
    #[inline]
    pub fn scale_x(&self) -> F2Dot14 {
        self.fixed_fields().scale_x.get()
    }

    /// Scale factor in y direction. For variation, use varIndexBase +
    /// 1.
    #[inline]
    pub fn scale_y(&self) -> F2Dot14 {
        self.fixed_fields().scale_y.get()
    }

    /// x coordinate for the center of scaling. For variation, use
    /// varIndexBase + 2.
    #[inline]
    pub fn center_x(&self) -> FWord {
        self.fixed_fields().center_x.get()
    }

    /// y coordinate for the center of scaling. For variation, use
    /// varIndexBase + 3.
    #[inline]
    pub fn center_y(&self) -> FWord {
        self.fixed_fields().center_y.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarScaleAroundCenter<'a> {
    fn type_name(&self) -> &str {
        "PaintVarScaleAroundCenter"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("scale_x", self.scale_x())),
            3usize => Some(Field::new("scale_y", self.scale_y())),
            4usize => Some(Field::new("center_x", self.center_x())),
            5usize => Some(Field::new("center_y", self.center_y())),
            6usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarScaleAroundCenter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintScaleUniformMarker {
    const FORMAT: u8 = 20;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintScaleUniformFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub scale: BigEndian<F2Dot14>,
}

impl FixedSize for PaintScaleUniformFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN;
}

/// [PaintScaleUniform](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintScaleUniformMarker {}

impl PaintScaleUniformMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn scale_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintScaleUniformMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.scale_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintScaleUniform<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintScaleUniformFixedFields = cursor.read_ref()?;
        cursor.finish(PaintScaleUniformMarker {}, fixed_fields)
    }
}

/// [PaintScaleUniform](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
pub type PaintScaleUniform<'a> =
    TableRef<'a, PaintScaleUniformMarker, PaintScaleUniformFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintScaleUniform<'a> {
    /// Set to 20.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Scale factor in x and y directions.
    #[inline]
    pub fn scale(&self) -> F2Dot14 {
        self.fixed_fields().scale.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintScaleUniform<'a> {
    fn type_name(&self) -> &str {
        "PaintScaleUniform"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("scale", self.scale())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintScaleUniform<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarScaleUniformMarker {
    const FORMAT: u8 = 21;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarScaleUniformFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub scale: BigEndian<F2Dot14>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarScaleUniformFixedFields {
    const RAW_BYTE_LEN: usize =
        u8::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN + u32::RAW_BYTE_LEN;
}

/// [PaintVarScaleUniform](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarScaleUniformMarker {}

impl PaintVarScaleUniformMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn scale_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.scale_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarScaleUniformMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarScaleUniform<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarScaleUniformFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarScaleUniformMarker {}, fixed_fields)
    }
}

/// [PaintVarScaleUniform](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
pub type PaintVarScaleUniform<'a> =
    TableRef<'a, PaintVarScaleUniformMarker, PaintVarScaleUniformFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarScaleUniform<'a> {
    /// Set to 21.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Scale factor in x and y directions. For variation, use
    /// varIndexBase + 0.
    #[inline]
    pub fn scale(&self) -> F2Dot14 {
        self.fixed_fields().scale.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarScaleUniform<'a> {
    fn type_name(&self) -> &str {
        "PaintVarScaleUniform"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("scale", self.scale())),
            3usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarScaleUniform<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintScaleUniformAroundCenterMarker {
    const FORMAT: u8 = 22;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintScaleUniformAroundCenterFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub scale: BigEndian<F2Dot14>,
    pub center_x: BigEndian<FWord>,
    pub center_y: BigEndian<FWord>,
}

impl FixedSize for PaintScaleUniformAroundCenterFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN;
}

/// [PaintScaleUniformAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintScaleUniformAroundCenterMarker {}

impl PaintScaleUniformAroundCenterMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn scale_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn center_x_byte_range(&self) -> Range<usize> {
        let start = self.scale_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn center_y_byte_range(&self) -> Range<usize> {
        let start = self.center_x_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintScaleUniformAroundCenterMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.center_y_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintScaleUniformAroundCenter<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintScaleUniformAroundCenterFixedFields = cursor.read_ref()?;
        cursor.finish(PaintScaleUniformAroundCenterMarker {}, fixed_fields)
    }
}

/// [PaintScaleUniformAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
pub type PaintScaleUniformAroundCenter<'a> =
    TableRef<'a, PaintScaleUniformAroundCenterMarker, PaintScaleUniformAroundCenterFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintScaleUniformAroundCenter<'a> {
    /// Set to 22.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Scale factor in x and y directions.
    #[inline]
    pub fn scale(&self) -> F2Dot14 {
        self.fixed_fields().scale.get()
    }

    /// x coordinate for the center of scaling.
    #[inline]
    pub fn center_x(&self) -> FWord {
        self.fixed_fields().center_x.get()
    }

    /// y coordinate for the center of scaling.
    #[inline]
    pub fn center_y(&self) -> FWord {
        self.fixed_fields().center_y.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintScaleUniformAroundCenter<'a> {
    fn type_name(&self) -> &str {
        "PaintScaleUniformAroundCenter"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("scale", self.scale())),
            3usize => Some(Field::new("center_x", self.center_x())),
            4usize => Some(Field::new("center_y", self.center_y())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintScaleUniformAroundCenter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarScaleUniformAroundCenterMarker {
    const FORMAT: u8 = 23;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarScaleUniformAroundCenterFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub scale: BigEndian<F2Dot14>,
    pub center_x: BigEndian<FWord>,
    pub center_y: BigEndian<FWord>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarScaleUniformAroundCenterFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [PaintVarScaleUniformAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarScaleUniformAroundCenterMarker {}

impl PaintVarScaleUniformAroundCenterMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn scale_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn center_x_byte_range(&self) -> Range<usize> {
        let start = self.scale_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn center_y_byte_range(&self) -> Range<usize> {
        let start = self.center_x_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.center_y_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarScaleUniformAroundCenterMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarScaleUniformAroundCenter<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarScaleUniformAroundCenterFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarScaleUniformAroundCenterMarker {}, fixed_fields)
    }
}

/// [PaintVarScaleUniformAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-16-to-23-paintscale-and-variant-scaling-formats) table
pub type PaintVarScaleUniformAroundCenter<'a> = TableRef<
    'a,
    PaintVarScaleUniformAroundCenterMarker,
    PaintVarScaleUniformAroundCenterFixedFields,
>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarScaleUniformAroundCenter<'a> {
    /// Set to 23.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Scale factor in x and y directions. For variation, use
    /// varIndexBase + 0.
    #[inline]
    pub fn scale(&self) -> F2Dot14 {
        self.fixed_fields().scale.get()
    }

    /// x coordinate for the center of scaling. For variation, use
    /// varIndexBase + 1.
    #[inline]
    pub fn center_x(&self) -> FWord {
        self.fixed_fields().center_x.get()
    }

    /// y coordinate for the center of scaling. For variation, use
    /// varIndexBase + 2.
    #[inline]
    pub fn center_y(&self) -> FWord {
        self.fixed_fields().center_y.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarScaleUniformAroundCenter<'a> {
    fn type_name(&self) -> &str {
        "PaintVarScaleUniformAroundCenter"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("scale", self.scale())),
            3usize => Some(Field::new("center_x", self.center_x())),
            4usize => Some(Field::new("center_y", self.center_y())),
            5usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarScaleUniformAroundCenter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintRotateMarker {
    const FORMAT: u8 = 24;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintRotateFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub angle: BigEndian<F2Dot14>,
}

impl FixedSize for PaintRotateFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN;
}

/// [PaintRotate](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-24-to-27-paintrotate-paintvarrotate-paintrotatearoundcenter-paintvarrotatearoundcenter) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintRotateMarker {}

impl PaintRotateMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn angle_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintRotateMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.angle_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintRotate<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintRotateFixedFields = cursor.read_ref()?;
        cursor.finish(PaintRotateMarker {}, fixed_fields)
    }
}

/// [PaintRotate](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-24-to-27-paintrotate-paintvarrotate-paintrotatearoundcenter-paintvarrotatearoundcenter) table
pub type PaintRotate<'a> = TableRef<'a, PaintRotateMarker, PaintRotateFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintRotate<'a> {
    /// Set to 24.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Rotation angle, 180 in counter-clockwise degrees per 1.0 of
    /// value.
    #[inline]
    pub fn angle(&self) -> F2Dot14 {
        self.fixed_fields().angle.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintRotate<'a> {
    fn type_name(&self) -> &str {
        "PaintRotate"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("angle", self.angle())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintRotate<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarRotateMarker {
    const FORMAT: u8 = 25;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarRotateFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub angle: BigEndian<F2Dot14>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarRotateFixedFields {
    const RAW_BYTE_LEN: usize =
        u8::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN + u32::RAW_BYTE_LEN;
}

/// [PaintVarRotate](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-24-to-27-paintrotate-paintvarrotate-paintrotatearoundcenter-paintvarrotatearoundcenter) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarRotateMarker {}

impl PaintVarRotateMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn angle_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.angle_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarRotateMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarRotate<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarRotateFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarRotateMarker {}, fixed_fields)
    }
}

/// [PaintVarRotate](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-24-to-27-paintrotate-paintvarrotate-paintrotatearoundcenter-paintvarrotatearoundcenter) table
pub type PaintVarRotate<'a> = TableRef<'a, PaintVarRotateMarker, PaintVarRotateFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarRotate<'a> {
    /// Set to 25.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Rotation angle, 180 in counter-clockwise degrees per 1.0 of
    /// value. For variation, use varIndexBase + 0.
    #[inline]
    pub fn angle(&self) -> F2Dot14 {
        self.fixed_fields().angle.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarRotate<'a> {
    fn type_name(&self) -> &str {
        "PaintVarRotate"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("angle", self.angle())),
            3usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarRotate<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintRotateAroundCenterMarker {
    const FORMAT: u8 = 26;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintRotateAroundCenterFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub angle: BigEndian<F2Dot14>,
    pub center_x: BigEndian<FWord>,
    pub center_y: BigEndian<FWord>,
}

impl FixedSize for PaintRotateAroundCenterFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN;
}

/// [PaintRotateAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-24-to-27-paintrotate-paintvarrotate-paintrotatearoundcenter-paintvarrotatearoundcenter) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintRotateAroundCenterMarker {}

impl PaintRotateAroundCenterMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn angle_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn center_x_byte_range(&self) -> Range<usize> {
        let start = self.angle_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn center_y_byte_range(&self) -> Range<usize> {
        let start = self.center_x_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintRotateAroundCenterMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.center_y_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintRotateAroundCenter<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintRotateAroundCenterFixedFields = cursor.read_ref()?;
        cursor.finish(PaintRotateAroundCenterMarker {}, fixed_fields)
    }
}

/// [PaintRotateAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-24-to-27-paintrotate-paintvarrotate-paintrotatearoundcenter-paintvarrotatearoundcenter) table
pub type PaintRotateAroundCenter<'a> =
    TableRef<'a, PaintRotateAroundCenterMarker, PaintRotateAroundCenterFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintRotateAroundCenter<'a> {
    /// Set to 26.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Rotation angle, 180 in counter-clockwise degrees per 1.0 of
    /// value.
    #[inline]
    pub fn angle(&self) -> F2Dot14 {
        self.fixed_fields().angle.get()
    }

    /// x coordinate for the center of rotation.
    #[inline]
    pub fn center_x(&self) -> FWord {
        self.fixed_fields().center_x.get()
    }

    /// y coordinate for the center of rotation.
    #[inline]
    pub fn center_y(&self) -> FWord {
        self.fixed_fields().center_y.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintRotateAroundCenter<'a> {
    fn type_name(&self) -> &str {
        "PaintRotateAroundCenter"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("angle", self.angle())),
            3usize => Some(Field::new("center_x", self.center_x())),
            4usize => Some(Field::new("center_y", self.center_y())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintRotateAroundCenter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarRotateAroundCenterMarker {
    const FORMAT: u8 = 27;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarRotateAroundCenterFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub angle: BigEndian<F2Dot14>,
    pub center_x: BigEndian<FWord>,
    pub center_y: BigEndian<FWord>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarRotateAroundCenterFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [PaintVarRotateAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-24-to-27-paintrotate-paintvarrotate-paintrotatearoundcenter-paintvarrotatearoundcenter) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarRotateAroundCenterMarker {}

impl PaintVarRotateAroundCenterMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn angle_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn center_x_byte_range(&self) -> Range<usize> {
        let start = self.angle_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn center_y_byte_range(&self) -> Range<usize> {
        let start = self.center_x_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.center_y_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarRotateAroundCenterMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarRotateAroundCenter<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarRotateAroundCenterFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarRotateAroundCenterMarker {}, fixed_fields)
    }
}

/// [PaintVarRotateAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-24-to-27-paintrotate-paintvarrotate-paintrotatearoundcenter-paintvarrotatearoundcenter) table
pub type PaintVarRotateAroundCenter<'a> =
    TableRef<'a, PaintVarRotateAroundCenterMarker, PaintVarRotateAroundCenterFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarRotateAroundCenter<'a> {
    /// Set to 27.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Rotation angle, 180 in counter-clockwise degrees per 1.0 of
    /// value. For variation, use varIndexBase + 0.
    #[inline]
    pub fn angle(&self) -> F2Dot14 {
        self.fixed_fields().angle.get()
    }

    /// x coordinate for the center of rotation. For variation, use
    /// varIndexBase + 1.
    #[inline]
    pub fn center_x(&self) -> FWord {
        self.fixed_fields().center_x.get()
    }

    /// y coordinate for the center of rotation. For variation, use
    /// varIndexBase + 2.
    #[inline]
    pub fn center_y(&self) -> FWord {
        self.fixed_fields().center_y.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarRotateAroundCenter<'a> {
    fn type_name(&self) -> &str {
        "PaintVarRotateAroundCenter"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("angle", self.angle())),
            3usize => Some(Field::new("center_x", self.center_x())),
            4usize => Some(Field::new("center_y", self.center_y())),
            5usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarRotateAroundCenter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintSkewMarker {
    const FORMAT: u8 = 28;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintSkewFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub x_skew_angle: BigEndian<F2Dot14>,
    pub y_skew_angle: BigEndian<F2Dot14>,
}

impl FixedSize for PaintSkewFixedFields {
    const RAW_BYTE_LEN: usize =
        u8::RAW_BYTE_LEN + Offset24::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN + F2Dot14::RAW_BYTE_LEN;
}

/// [PaintSkew](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-28-to-31-paintskew-paintvarskew-paintskewaroundcenter-paintvarskewaroundcenter) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintSkewMarker {}

impl PaintSkewMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn x_skew_angle_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn y_skew_angle_byte_range(&self) -> Range<usize> {
        let start = self.x_skew_angle_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintSkewMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.y_skew_angle_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintSkew<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintSkewFixedFields = cursor.read_ref()?;
        cursor.finish(PaintSkewMarker {}, fixed_fields)
    }
}

/// [PaintSkew](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-28-to-31-paintskew-paintvarskew-paintskewaroundcenter-paintvarskewaroundcenter) table
pub type PaintSkew<'a> = TableRef<'a, PaintSkewMarker, PaintSkewFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintSkew<'a> {
    /// Set to 28.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Angle of skew in the direction of the x-axis, 180 in
    /// counter-clockwise degrees per 1.0 of value.
    #[inline]
    pub fn x_skew_angle(&self) -> F2Dot14 {
        self.fixed_fields().x_skew_angle.get()
    }

    /// Angle of skew in the direction of the y-axis, 180 in
    /// counter-clockwise degrees per 1.0 of value.
    #[inline]
    pub fn y_skew_angle(&self) -> F2Dot14 {
        self.fixed_fields().y_skew_angle.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintSkew<'a> {
    fn type_name(&self) -> &str {
        "PaintSkew"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("x_skew_angle", self.x_skew_angle())),
            3usize => Some(Field::new("y_skew_angle", self.y_skew_angle())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintSkew<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarSkewMarker {
    const FORMAT: u8 = 29;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarSkewFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub x_skew_angle: BigEndian<F2Dot14>,
    pub y_skew_angle: BigEndian<F2Dot14>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarSkewFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [PaintVarSkew](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-28-to-31-paintskew-paintvarskew-paintskewaroundcenter-paintvarskewaroundcenter) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarSkewMarker {}

impl PaintVarSkewMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn x_skew_angle_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn y_skew_angle_byte_range(&self) -> Range<usize> {
        let start = self.x_skew_angle_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.y_skew_angle_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarSkewMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarSkew<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarSkewFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarSkewMarker {}, fixed_fields)
    }
}

/// [PaintVarSkew](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-28-to-31-paintskew-paintvarskew-paintskewaroundcenter-paintvarskewaroundcenter) table
pub type PaintVarSkew<'a> = TableRef<'a, PaintVarSkewMarker, PaintVarSkewFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarSkew<'a> {
    /// Set to 29.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Angle of skew in the direction of the x-axis, 180  in
    /// counter-clockwise degrees per 1.0 of value. For variation, use
    /// varIndexBase + 0.
    #[inline]
    pub fn x_skew_angle(&self) -> F2Dot14 {
        self.fixed_fields().x_skew_angle.get()
    }

    /// Angle of skew in the direction of the y-axis, 180 in
    /// counter-clockwise degrees per 1.0 of value. For variation, use
    /// varIndexBase + 1.
    #[inline]
    pub fn y_skew_angle(&self) -> F2Dot14 {
        self.fixed_fields().y_skew_angle.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarSkew<'a> {
    fn type_name(&self) -> &str {
        "PaintVarSkew"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("x_skew_angle", self.x_skew_angle())),
            3usize => Some(Field::new("y_skew_angle", self.y_skew_angle())),
            4usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarSkew<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintSkewAroundCenterMarker {
    const FORMAT: u8 = 30;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintSkewAroundCenterFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub x_skew_angle: BigEndian<F2Dot14>,
    pub y_skew_angle: BigEndian<F2Dot14>,
    pub center_x: BigEndian<FWord>,
    pub center_y: BigEndian<FWord>,
}

impl FixedSize for PaintSkewAroundCenterFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN;
}

/// [PaintSkewAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-28-to-31-paintskew-paintvarskew-paintskewaroundcenter-paintvarskewaroundcenter) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintSkewAroundCenterMarker {}

impl PaintSkewAroundCenterMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn x_skew_angle_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn y_skew_angle_byte_range(&self) -> Range<usize> {
        let start = self.x_skew_angle_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn center_x_byte_range(&self) -> Range<usize> {
        let start = self.y_skew_angle_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn center_y_byte_range(&self) -> Range<usize> {
        let start = self.center_x_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintSkewAroundCenterMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.center_y_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintSkewAroundCenter<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintSkewAroundCenterFixedFields = cursor.read_ref()?;
        cursor.finish(PaintSkewAroundCenterMarker {}, fixed_fields)
    }
}

/// [PaintSkewAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-28-to-31-paintskew-paintvarskew-paintskewaroundcenter-paintvarskewaroundcenter) table
pub type PaintSkewAroundCenter<'a> =
    TableRef<'a, PaintSkewAroundCenterMarker, PaintSkewAroundCenterFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintSkewAroundCenter<'a> {
    /// Set to 30.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Angle of skew in the direction of the x-axis, 180 in
    /// counter-clockwise degrees per 1.0 of value.
    #[inline]
    pub fn x_skew_angle(&self) -> F2Dot14 {
        self.fixed_fields().x_skew_angle.get()
    }

    /// Angle of skew in the direction of the y-axis, 180 in
    /// counter-clockwise degrees per 1.0 of value.
    #[inline]
    pub fn y_skew_angle(&self) -> F2Dot14 {
        self.fixed_fields().y_skew_angle.get()
    }

    /// x coordinate for the center of rotation.
    #[inline]
    pub fn center_x(&self) -> FWord {
        self.fixed_fields().center_x.get()
    }

    /// y coordinate for the center of rotation.
    #[inline]
    pub fn center_y(&self) -> FWord {
        self.fixed_fields().center_y.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintSkewAroundCenter<'a> {
    fn type_name(&self) -> &str {
        "PaintSkewAroundCenter"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("x_skew_angle", self.x_skew_angle())),
            3usize => Some(Field::new("y_skew_angle", self.y_skew_angle())),
            4usize => Some(Field::new("center_x", self.center_x())),
            5usize => Some(Field::new("center_y", self.center_y())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintSkewAroundCenter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintVarSkewAroundCenterMarker {
    const FORMAT: u8 = 31;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintVarSkewAroundCenterFixedFields {
    pub format: u8,
    pub paint_offset: BigEndian<Offset24>,
    pub x_skew_angle: BigEndian<F2Dot14>,
    pub y_skew_angle: BigEndian<F2Dot14>,
    pub center_x: BigEndian<FWord>,
    pub center_y: BigEndian<FWord>,
    pub var_index_base: BigEndian<u32>,
}

impl FixedSize for PaintVarSkewAroundCenterFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + F2Dot14::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + FWord::RAW_BYTE_LEN
        + u32::RAW_BYTE_LEN;
}

/// [PaintVarSkewAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-28-to-31-paintskew-paintvarskew-paintskewaroundcenter-paintvarskewaroundcenter) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintVarSkewAroundCenterMarker {}

impl PaintVarSkewAroundCenterMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn x_skew_angle_byte_range(&self) -> Range<usize> {
        let start = self.paint_offset_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn y_skew_angle_byte_range(&self) -> Range<usize> {
        let start = self.x_skew_angle_byte_range().end;
        start..start + F2Dot14::RAW_BYTE_LEN
    }

    pub fn center_x_byte_range(&self) -> Range<usize> {
        let start = self.y_skew_angle_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn center_y_byte_range(&self) -> Range<usize> {
        let start = self.center_x_byte_range().end;
        start..start + FWord::RAW_BYTE_LEN
    }

    pub fn var_index_base_byte_range(&self) -> Range<usize> {
        let start = self.center_y_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintVarSkewAroundCenterMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.var_index_base_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintVarSkewAroundCenter<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintVarSkewAroundCenterFixedFields = cursor.read_ref()?;
        cursor.finish(PaintVarSkewAroundCenterMarker {}, fixed_fields)
    }
}

/// [PaintVarSkewAroundCenter](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#formats-28-to-31-paintskew-paintvarskew-paintskewaroundcenter-paintvarskewaroundcenter) table
pub type PaintVarSkewAroundCenter<'a> =
    TableRef<'a, PaintVarSkewAroundCenterMarker, PaintVarSkewAroundCenterFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintVarSkewAroundCenter<'a> {
    /// Set to 31.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a Paint subtable.
    #[inline]
    pub fn paint_offset(&self) -> Offset24 {
        self.fixed_fields().paint_offset.get()
    }

    /// Attempt to resolve [`paint_offset`][Self::paint_offset].
    #[inline]
    pub fn paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.paint_offset().resolve(data)
    }

    /// Angle of skew in the direction of the x-axis, 180 in
    /// counter-clockwise degrees per 1.0 of value. For variation, use
    /// varIndexBase + 0.
    #[inline]
    pub fn x_skew_angle(&self) -> F2Dot14 {
        self.fixed_fields().x_skew_angle.get()
    }

    /// Angle of skew in the direction of the y-axis, 180 in
    /// counter-clockwise degrees per 1.0 of value. For variation, use
    /// varIndexBase + 1.
    #[inline]
    pub fn y_skew_angle(&self) -> F2Dot14 {
        self.fixed_fields().y_skew_angle.get()
    }

    /// x coordinate for the center of rotation. For variation, use
    /// varIndexBase + 2.
    #[inline]
    pub fn center_x(&self) -> FWord {
        self.fixed_fields().center_x.get()
    }

    /// y coordinate for the center of rotation. For variation, use
    /// varIndexBase + 3.
    #[inline]
    pub fn center_y(&self) -> FWord {
        self.fixed_fields().center_y.get()
    }

    /// Base index into DeltaSetIndexMap.
    #[inline]
    pub fn var_index_base(&self) -> u32 {
        self.fixed_fields().var_index_base.get()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintVarSkewAroundCenter<'a> {
    fn type_name(&self) -> &str {
        "PaintVarSkewAroundCenter"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "paint_offset",
                FieldType::offset(self.paint_offset(), self.paint()),
            )),
            2usize => Some(Field::new("x_skew_angle", self.x_skew_angle())),
            3usize => Some(Field::new("y_skew_angle", self.y_skew_angle())),
            4usize => Some(Field::new("center_x", self.center_x())),
            5usize => Some(Field::new("center_y", self.center_y())),
            6usize => Some(Field::new("var_index_base", self.var_index_base())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintVarSkewAroundCenter<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

impl Format<u8> for PaintCompositeMarker {
    const FORMAT: u8 = 32;
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct PaintCompositeFixedFields {
    pub format: u8,
    pub source_paint_offset: BigEndian<Offset24>,
    pub composite_mode: BigEndian<CompositeMode>,
    pub backdrop_paint_offset: BigEndian<Offset24>,
}

impl FixedSize for PaintCompositeFixedFields {
    const RAW_BYTE_LEN: usize = u8::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN
        + CompositeMode::RAW_BYTE_LEN
        + Offset24::RAW_BYTE_LEN;
}

/// [PaintComposite](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#format-32-paintcomposite) table
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct PaintCompositeMarker {}

impl PaintCompositeMarker {
    pub fn format_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn source_paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.format_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }

    pub fn composite_mode_byte_range(&self) -> Range<usize> {
        let start = self.source_paint_offset_byte_range().end;
        start..start + CompositeMode::RAW_BYTE_LEN
    }

    pub fn backdrop_paint_offset_byte_range(&self) -> Range<usize> {
        let start = self.composite_mode_byte_range().end;
        start..start + Offset24::RAW_BYTE_LEN
    }
}

impl MinByteRange for PaintCompositeMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.backdrop_paint_offset_byte_range().end
    }
}

impl<'a> FontRead<'a> for PaintComposite<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a PaintCompositeFixedFields = cursor.read_ref()?;
        cursor.finish(PaintCompositeMarker {}, fixed_fields)
    }
}

/// [PaintComposite](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#format-32-paintcomposite) table
pub type PaintComposite<'a> = TableRef<'a, PaintCompositeMarker, PaintCompositeFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> PaintComposite<'a> {
    /// Set to 32.
    #[inline]
    pub fn format(&self) -> u8 {
        self.fixed_fields().format
    }

    /// Offset to a source Paint table.
    #[inline]
    pub fn source_paint_offset(&self) -> Offset24 {
        self.fixed_fields().source_paint_offset.get()
    }

    /// Attempt to resolve [`source_paint_offset`][Self::source_paint_offset].
    #[inline]
    pub fn source_paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.source_paint_offset().resolve(data)
    }

    /// A CompositeMode enumeration value.
    #[inline]
    pub fn composite_mode(&self) -> CompositeMode {
        self.fixed_fields().composite_mode.get()
    }

    /// Offset to a backdrop Paint table.
    #[inline]
    pub fn backdrop_paint_offset(&self) -> Offset24 {
        self.fixed_fields().backdrop_paint_offset.get()
    }

    /// Attempt to resolve [`backdrop_paint_offset`][Self::backdrop_paint_offset].
    #[inline]
    pub fn backdrop_paint(&self) -> Result<Paint<'a>, ReadError> {
        let data = self.data;
        self.backdrop_paint_offset().resolve(data)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for PaintComposite<'a> {
    fn type_name(&self) -> &str {
        "PaintComposite"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("format", self.format())),
            1usize => Some(Field::new(
                "source_paint_offset",
                FieldType::offset(self.source_paint_offset(), self.source_paint()),
            )),
            2usize => Some(Field::new("composite_mode", self.composite_mode())),
            3usize => Some(Field::new(
                "backdrop_paint_offset",
                FieldType::offset(self.backdrop_paint_offset(), self.backdrop_paint()),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for PaintComposite<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// [CompositeMode](https://learn.microsoft.com/en-us/typography/opentype/spec/colr#format-32-paintcomposite) enumeration
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq, Hash, PartialOrd, Ord)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
#[repr(u8)]
#[allow(clippy::manual_non_exhaustive)]
pub enum CompositeMode {
    Clear = 0,
    Src = 1,
    Dest = 2,
    #[default]
    SrcOver = 3,
    DestOver = 4,
    SrcIn = 5,
    DestIn = 6,
    SrcOut = 7,
    DestOut = 8,
    SrcAtop = 9,
    DestAtop = 10,
    Xor = 11,
    Plus = 12,
    Screen = 13,
    Overlay = 14,
    Darken = 15,
    Lighten = 16,
    ColorDodge = 17,
    ColorBurn = 18,
    HardLight = 19,
    SoftLight = 20,
    Difference = 21,
    Exclusion = 22,
    Multiply = 23,
    HslHue = 24,
    HslSaturation = 25,
    HslColor = 26,
    HslLuminosity = 27,
    #[doc(hidden)]
    /// If font data is malformed we will map unknown values to this variant
    Unknown,
}

impl CompositeMode {
    /// Create from a raw scalar.
    ///
    /// This will never fail; unknown values will be mapped to the `Unknown` variant
    pub fn new(raw: u8) -> Self {
        match raw {
            0 => Self::Clear,
            1 => Self::Src,
            2 => Self::Dest,
            3 => Self::SrcOver,
            4 => Self::DestOver,
            5 => Self::SrcIn,
            6 => Self::DestIn,
            7 => Self::SrcOut,
            8 => Self::DestOut,
            9 => Self::SrcAtop,
            10 => Self::DestAtop,
            11 => Self::Xor,
            12 => Self::Plus,
            13 => Self::Screen,
            14 => Self::Overlay,
            15 => Self::Darken,
            16 => Self::Lighten,
            17 => Self::ColorDodge,
            18 => Self::ColorBurn,
            19 => Self::HardLight,
            20 => Self::SoftLight,
            21 => Self::Difference,
            22 => Self::Exclusion,
            23 => Self::Multiply,
            24 => Self::HslHue,
            25 => Self::HslSaturation,
            26 => Self::HslColor,
            27 => Self::HslLuminosity,
            _ => Self::Unknown,
        }
    }
}

impl font_types::Scalar for CompositeMode {
    type Raw = <u8 as font_types::Scalar>::Raw;
    fn to_raw(self) -> Self::Raw {
        (self as u8).to_raw()
    }
    fn from_raw(raw: Self::Raw) -> Self {
        let t = <u8>::from_raw(raw);
        Self::new(t)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> From<CompositeMode> for FieldType<'a> {
    fn from(src: CompositeMode) -> FieldType<'a> {
        (src as u8).into()
    }
}
