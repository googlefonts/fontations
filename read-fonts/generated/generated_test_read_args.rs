// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct BaseArrayMarker {
    mark_class_count: u16,
}

impl<'a> MinByteRange for BaseArray<'a> {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.base_records_byte_range().end
    }
}

impl ReadArgs for BaseArray<'_> {
    type Args = u16;
}

impl<'a> FontReadWithArgs<'a> for BaseArray<'a> {
    fn read_with_args(data: FontData<'a>, args: &u16) -> Result<Self, ReadError> {
        let mark_class_count = *args;
        if data.len() < Self::MIN_SIZE {
            return Err(ReadError::OutOfBounds);
        }
        Ok(Self {
            data,
            shape: BaseArrayMarker { mark_class_count },
        })
    }
    unsafe fn read_with_args_unchecked(data: FontData<'a>, args: &Self::Args) -> Self {
        let mark_class_count = *args;
        Self {
            data,
            shape: BaseArrayMarker { mark_class_count },
        }
    }
}

impl<'a> BaseArray<'a> {
    /// A constructor that requires additional arguments.
    ///
    /// This type requires some external state in order to be
    /// parsed.
    pub fn read(data: FontData<'a>, mark_class_count: u16) -> Result<Self, ReadError> {
        let args = mark_class_count;
        Self::read_with_args(data, &args)
    }
}

pub type BaseArray<'a> = TableRef<'a, BaseArrayMarker>;

#[allow(clippy::needless_lifetimes)]
impl<'a> BaseArray<'a> {
    pub const MIN_SIZE: usize = u16::RAW_BYTE_LEN;

    pub fn base_count_byte_range(&self) -> Range<usize> {
        let start = 0;
        let end = start + u16::RAW_BYTE_LEN;
        start..end
    }

    pub fn base_records_byte_range(&self) -> Range<usize> {
        let base_count = self.base_count();
        let start = self.base_count_byte_range().end;
        let end = start
            + (base_count as usize).saturating_mul(
                <BaseRecord as ComputeSize>::compute_size(&self.mark_class_count()).unwrap_or(0),
            );
        start..end
    }

    /// Number of BaseRecords
    pub fn base_count(&self) -> u16 {
        let range = self.base_count_byte_range();
        unsafe { self.data.read_at_unchecked(range.start) }
    }

    /// Array of BaseRecords, in order of baseCoverage Index.
    pub fn base_records(&self) -> ComputedArray<'a, BaseRecord<'a>> {
        let range = self.base_records_byte_range();
        self.data
            .read_with_args(range, &self.mark_class_count())
            .unwrap()
    }

    pub(crate) fn mark_class_count(&self) -> u16 {
        self.shape.mark_class_count
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for BaseArray<'a> {
    fn type_name(&self) -> &str {
        "BaseArray"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("base_count", self.base_count())),
            1usize => Some(Field::new(
                "base_records",
                traversal::FieldType::computed_array(
                    "BaseRecord",
                    self.base_records(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for BaseArray<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

/// Part of [BaseArray]
#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub struct BaseRecord<'a> {
    /// Array of offsets (one per mark class) to Anchor tables. Offsets
    /// are from beginning of BaseArray table, ordered by class
    /// (offsets may be NULL).
    pub base_anchor_offsets: &'a [BigEndian<u16>],
}

impl<'a> BaseRecord<'a> {
    /// Array of offsets (one per mark class) to Anchor tables. Offsets
    /// are from beginning of BaseArray table, ordered by class
    /// (offsets may be NULL).
    pub fn base_anchor_offsets(&self) -> &'a [BigEndian<u16>] {
        self.base_anchor_offsets
    }
}

impl ReadArgs for BaseRecord<'_> {
    type Args = u16;
}

impl ComputeSize for BaseRecord<'_> {
    #[allow(clippy::needless_question_mark)]
    fn compute_size(args: &u16) -> Result<usize, ReadError> {
        let mark_class_count = *args;
        Ok((mark_class_count as usize).saturating_mul(u16::RAW_BYTE_LEN))
    }
}

impl<'a> FontReadWithArgs<'a> for BaseRecord<'a> {
    fn read_with_args(data: FontData<'a>, args: &u16) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let mark_class_count = *args;
        Ok(Self {
            base_anchor_offsets: cursor.read_array(mark_class_count as usize)?,
        })
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> BaseRecord<'a> {
    /// A constructor that requires additional arguments.
    ///
    /// This type requires some external state in order to be
    /// parsed.
    pub fn read(data: FontData<'a>, mark_class_count: u16) -> Result<Self, ReadError> {
        let args = mark_class_count;
        Self::read_with_args(data, &args)
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeRecord<'a> for BaseRecord<'a> {
    fn traverse(self, data: FontData<'a>) -> RecordResolver<'a> {
        RecordResolver {
            name: "BaseRecord",
            get_field: Box::new(move |idx, _data| match idx {
                0usize => Some(Field::new(
                    "base_anchor_offsets",
                    self.base_anchor_offsets(),
                )),
                _ => None,
            }),
            data,
        }
    }
}
