// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct OtKernFixedFields {
    pub version: BigEndian<u16>,
    pub n_tables: BigEndian<u16>,
}

impl FixedSize for OtKernFixedFields {
    const RAW_BYTE_LEN: usize = u16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN;
}

/// The OpenType [kerning](https://learn.microsoft.com/en-us/typography/opentype/spec/kern) table.
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct OtKernMarker {
    subtable_data_byte_len: usize,
}

impl OtKernMarker {
    pub fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn n_tables_byte_range(&self) -> Range<usize> {
        let start = self.version_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn subtable_data_byte_range(&self) -> Range<usize> {
        let start = self.n_tables_byte_range().end;
        start..start + self.subtable_data_byte_len
    }
}

impl MinByteRange for OtKernMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.subtable_data_byte_range().end
    }
}

impl<'a> FontRead<'a> for OtKern<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a OtKernFixedFields = cursor.read_ref()?;
        let subtable_data_byte_len = cursor.remaining_bytes() / u8::RAW_BYTE_LEN * u8::RAW_BYTE_LEN;
        cursor.advance_by(subtable_data_byte_len);
        cursor.finish(
            OtKernMarker {
                subtable_data_byte_len,
            },
            fixed_fields,
        )
    }
}

/// The OpenType [kerning](https://learn.microsoft.com/en-us/typography/opentype/spec/kern) table.
pub type OtKern<'a> = TableRef<'a, OtKernMarker, OtKernFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> OtKern<'a> {
    /// Table version numberâ€”set to 0.
    #[inline]
    pub fn version(&self) -> u16 {
        self.fixed_fields().version.get()
    }

    /// Number of subtables in the kerning table.
    #[inline]
    pub fn n_tables(&self) -> u16 {
        self.fixed_fields().n_tables.get()
    }

    /// Data for subtables, immediately following the header.
    #[inline]
    pub fn subtable_data(&self) -> &'a [u8] {
        let range = self.shape.subtable_data_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for OtKern<'a> {
    fn type_name(&self) -> &str {
        "OtKern"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("version", self.version())),
            1usize => Some(Field::new("n_tables", self.n_tables())),
            2usize => Some(Field::new("subtable_data", self.subtable_data())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for OtKern<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct AatKernFixedFields {
    pub version: BigEndian<MajorMinor>,
    pub n_tables: BigEndian<u32>,
}

impl FixedSize for AatKernFixedFields {
    const RAW_BYTE_LEN: usize = MajorMinor::RAW_BYTE_LEN + u32::RAW_BYTE_LEN;
}

/// The Apple Advanced Typography [kerning](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html) table.
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct AatKernMarker {
    subtable_data_byte_len: usize,
}

impl AatKernMarker {
    pub fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + MajorMinor::RAW_BYTE_LEN
    }

    pub fn n_tables_byte_range(&self) -> Range<usize> {
        let start = self.version_byte_range().end;
        start..start + u32::RAW_BYTE_LEN
    }

    pub fn subtable_data_byte_range(&self) -> Range<usize> {
        let start = self.n_tables_byte_range().end;
        start..start + self.subtable_data_byte_len
    }
}

impl MinByteRange for AatKernMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.subtable_data_byte_range().end
    }
}

impl<'a> FontRead<'a> for AatKern<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a AatKernFixedFields = cursor.read_ref()?;
        let subtable_data_byte_len = cursor.remaining_bytes() / u8::RAW_BYTE_LEN * u8::RAW_BYTE_LEN;
        cursor.advance_by(subtable_data_byte_len);
        cursor.finish(
            AatKernMarker {
                subtable_data_byte_len,
            },
            fixed_fields,
        )
    }
}

/// The Apple Advanced Typography [kerning](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html) table.
pub type AatKern<'a> = TableRef<'a, AatKernMarker, AatKernFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> AatKern<'a> {
    /// The version number of the kerning table (0x00010000 for the current version).
    #[inline]
    pub fn version(&self) -> MajorMinor {
        self.fixed_fields().version.get()
    }

    /// The number of subtables included in the kerning table.
    #[inline]
    pub fn n_tables(&self) -> u32 {
        self.fixed_fields().n_tables.get()
    }

    /// Data for subtables, immediately following the header.    
    #[inline]
    pub fn subtable_data(&self) -> &'a [u8] {
        let range = self.shape.subtable_data_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for AatKern<'a> {
    fn type_name(&self) -> &str {
        "AatKern"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("version", self.version())),
            1usize => Some(Field::new("n_tables", self.n_tables())),
            2usize => Some(Field::new("subtable_data", self.subtable_data())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for AatKern<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct OtSubtableFixedFields {
    pub version: BigEndian<u16>,
    pub length: BigEndian<u16>,
    pub coverage: BigEndian<u16>,
}

impl FixedSize for OtSubtableFixedFields {
    const RAW_BYTE_LEN: usize = u16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN;
}

/// A subtable in an OT `kern` table.
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct OtSubtableMarker {
    data_byte_len: usize,
}

impl OtSubtableMarker {
    pub fn version_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn length_byte_range(&self) -> Range<usize> {
        let start = self.version_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn coverage_byte_range(&self) -> Range<usize> {
        let start = self.length_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn data_byte_range(&self) -> Range<usize> {
        let start = self.coverage_byte_range().end;
        start..start + self.data_byte_len
    }
}

impl MinByteRange for OtSubtableMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.data_byte_range().end
    }
}

impl<'a> FontRead<'a> for OtSubtable<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a OtSubtableFixedFields = cursor.read_ref()?;
        let data_byte_len = cursor.remaining_bytes() / u8::RAW_BYTE_LEN * u8::RAW_BYTE_LEN;
        cursor.advance_by(data_byte_len);
        cursor.finish(OtSubtableMarker { data_byte_len }, fixed_fields)
    }
}

/// A subtable in an OT `kern` table.
pub type OtSubtable<'a> = TableRef<'a, OtSubtableMarker, OtSubtableFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> OtSubtable<'a> {
    /// Kern subtable version number-- set to 0.
    #[inline]
    pub fn version(&self) -> u16 {
        self.fixed_fields().version.get()
    }

    /// The length of this subtable in bytes, including this header.
    #[inline]
    pub fn length(&self) -> u16 {
        self.fixed_fields().length.get()
    }

    /// Circumstances under which this table is used.
    #[inline]
    pub fn coverage(&self) -> u16 {
        self.fixed_fields().coverage.get()
    }

    /// Subtable specific data.
    #[inline]
    pub fn data(&self) -> &'a [u8] {
        let range = self.shape.data_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for OtSubtable<'a> {
    fn type_name(&self) -> &str {
        "OtSubtable"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("version", self.version())),
            1usize => Some(Field::new("length", self.length())),
            2usize => Some(Field::new("coverage", self.coverage())),
            3usize => Some(Field::new("data", self.data())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for OtSubtable<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct AatSubtableFixedFields {
    pub length: BigEndian<u32>,
    pub coverage: BigEndian<u16>,
    pub tuple_index: BigEndian<u16>,
}

impl FixedSize for AatSubtableFixedFields {
    const RAW_BYTE_LEN: usize = u32::RAW_BYTE_LEN + u16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN;
}

/// A subtable in an AAT `kern` table.
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct AatSubtableMarker {
    data_byte_len: usize,
}

impl AatSubtableMarker {
    pub fn length_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u32::RAW_BYTE_LEN
    }

    pub fn coverage_byte_range(&self) -> Range<usize> {
        let start = self.length_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn tuple_index_byte_range(&self) -> Range<usize> {
        let start = self.coverage_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn data_byte_range(&self) -> Range<usize> {
        let start = self.tuple_index_byte_range().end;
        start..start + self.data_byte_len
    }
}

impl MinByteRange for AatSubtableMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.data_byte_range().end
    }
}

impl<'a> FontRead<'a> for AatSubtable<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a AatSubtableFixedFields = cursor.read_ref()?;
        let data_byte_len = cursor.remaining_bytes() / u8::RAW_BYTE_LEN * u8::RAW_BYTE_LEN;
        cursor.advance_by(data_byte_len);
        cursor.finish(AatSubtableMarker { data_byte_len }, fixed_fields)
    }
}

/// A subtable in an AAT `kern` table.
pub type AatSubtable<'a> = TableRef<'a, AatSubtableMarker, AatSubtableFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> AatSubtable<'a> {
    /// The length of this subtable in bytes, including this header.
    #[inline]
    pub fn length(&self) -> u32 {
        self.fixed_fields().length.get()
    }

    /// Circumstances under which this table is used.
    #[inline]
    pub fn coverage(&self) -> u16 {
        self.fixed_fields().coverage.get()
    }

    /// The tuple index (used for variations fonts). This value specifies which tuple this subtable covers.
    #[inline]
    pub fn tuple_index(&self) -> u16 {
        self.fixed_fields().tuple_index.get()
    }

    /// Subtable specific data.
    #[inline]
    pub fn data(&self) -> &'a [u8] {
        let range = self.shape.data_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for AatSubtable<'a> {
    fn type_name(&self) -> &str {
        "AatSubtable"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("length", self.length())),
            1usize => Some(Field::new("coverage", self.coverage())),
            2usize => Some(Field::new("tuple_index", self.tuple_index())),
            3usize => Some(Field::new("data", self.data())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for AatSubtable<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct Subtable0FixedFields {
    pub n_pairs: BigEndian<u16>,
    pub search_range: BigEndian<u16>,
    pub entry_selector: BigEndian<u16>,
    pub range_shift: BigEndian<u16>,
}

impl FixedSize for Subtable0FixedFields {
    const RAW_BYTE_LEN: usize =
        u16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN;
}

/// The type 0 `kern` subtable.
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct Subtable0Marker {
    pairs_byte_len: usize,
}

impl Subtable0Marker {
    pub fn n_pairs_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn search_range_byte_range(&self) -> Range<usize> {
        let start = self.n_pairs_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn entry_selector_byte_range(&self) -> Range<usize> {
        let start = self.search_range_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn range_shift_byte_range(&self) -> Range<usize> {
        let start = self.entry_selector_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn pairs_byte_range(&self) -> Range<usize> {
        let start = self.range_shift_byte_range().end;
        start..start + self.pairs_byte_len
    }
}

impl MinByteRange for Subtable0Marker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.pairs_byte_range().end
    }
}

impl<'a> FontRead<'a> for Subtable0<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a Subtable0FixedFields = cursor.read_ref()?;
        let n_pairs = fixed_fields.n_pairs.get();
        let pairs_byte_len = (n_pairs as usize)
            .checked_mul(Subtable0Pair::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(pairs_byte_len);
        cursor.finish(Subtable0Marker { pairs_byte_len }, fixed_fields)
    }
}

/// The type 0 `kern` subtable.
pub type Subtable0<'a> = TableRef<'a, Subtable0Marker, Subtable0FixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> Subtable0<'a> {
    /// The number of kerning pairs in this subtable.
    #[inline]
    pub fn n_pairs(&self) -> u16 {
        self.fixed_fields().n_pairs.get()
    }

    /// The largest power of two less than or equal to the value of nPairs, multiplied by the size in bytes of an entry in the subtable.
    #[inline]
    pub fn search_range(&self) -> u16 {
        self.fixed_fields().search_range.get()
    }

    /// This is calculated as log2 of the largest power of two less than or equal to the value of nPairs. This value indicates how many iterations of the search loop have to be made. For example, in a list of eight items, there would be three iterations of the loop.
    #[inline]
    pub fn entry_selector(&self) -> u16 {
        self.fixed_fields().entry_selector.get()
    }

    /// The value of nPairs minus the largest power of two less than or equal to nPairs. This is multiplied by the size in bytes of an entry in the table.
    #[inline]
    pub fn range_shift(&self) -> u16 {
        self.fixed_fields().range_shift.get()
    }

    /// Kerning records.
    #[inline]
    pub fn pairs(&self) -> &'a [Subtable0Pair] {
        let range = self.shape.pairs_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for Subtable0<'a> {
    fn type_name(&self) -> &str {
        "Subtable0"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("n_pairs", self.n_pairs())),
            1usize => Some(Field::new("search_range", self.search_range())),
            2usize => Some(Field::new("entry_selector", self.entry_selector())),
            3usize => Some(Field::new("range_shift", self.range_shift())),
            4usize => Some(Field::new(
                "pairs",
                traversal::FieldType::array_of_records(
                    stringify!(Subtable0Pair),
                    self.pairs(),
                    self.offset_data(),
                ),
            )),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for Subtable0<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct Subtable2ClassTableFixedFields {
    pub first_glyph: BigEndian<GlyphId16>,
    pub n_glyphs: BigEndian<u16>,
}

impl FixedSize for Subtable2ClassTableFixedFields {
    const RAW_BYTE_LEN: usize = GlyphId16::RAW_BYTE_LEN + u16::RAW_BYTE_LEN;
}

/// Class table for the type 2 `kern` subtable.
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct Subtable2ClassTableMarker {
    offsets_byte_len: usize,
}

impl Subtable2ClassTableMarker {
    pub fn first_glyph_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + GlyphId16::RAW_BYTE_LEN
    }

    pub fn n_glyphs_byte_range(&self) -> Range<usize> {
        let start = self.first_glyph_byte_range().end;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn offsets_byte_range(&self) -> Range<usize> {
        let start = self.n_glyphs_byte_range().end;
        start..start + self.offsets_byte_len
    }
}

impl MinByteRange for Subtable2ClassTableMarker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.offsets_byte_range().end
    }
}

impl<'a> FontRead<'a> for Subtable2ClassTable<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a Subtable2ClassTableFixedFields = cursor.read_ref()?;
        let n_glyphs = fixed_fields.n_glyphs.get();
        let offsets_byte_len = (n_glyphs as usize)
            .checked_mul(u16::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(offsets_byte_len);
        cursor.finish(Subtable2ClassTableMarker { offsets_byte_len }, fixed_fields)
    }
}

/// Class table for the type 2 `kern` subtable.
pub type Subtable2ClassTable<'a> =
    TableRef<'a, Subtable2ClassTableMarker, Subtable2ClassTableFixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> Subtable2ClassTable<'a> {
    /// First glyph in class range.
    #[inline]
    pub fn first_glyph(&self) -> GlyphId16 {
        self.fixed_fields().first_glyph.get()
    }

    /// Number of glyph in class range.
    #[inline]
    pub fn n_glyphs(&self) -> u16 {
        self.fixed_fields().n_glyphs.get()
    }

    /// The offsets array for all of the glyphs in the range.
    #[inline]
    pub fn offsets(&self) -> &'a [BigEndian<u16>] {
        let range = self.shape.offsets_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for Subtable2ClassTable<'a> {
    fn type_name(&self) -> &str {
        "Subtable2ClassTable"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("first_glyph", self.first_glyph())),
            1usize => Some(Field::new("n_glyphs", self.n_glyphs())),
            2usize => Some(Field::new("offsets", self.offsets())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for Subtable2ClassTable<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}

#[derive(Copy, Clone, Debug, bytemuck :: AnyBitPattern)]
#[repr(C)]
#[repr(packed)]
pub struct Subtable3FixedFields {
    pub glyph_count: BigEndian<u16>,
    pub kern_value_count: u8,
    pub left_class_count: u8,
    pub right_class_count: u8,
    pub flags: u8,
}

impl FixedSize for Subtable3FixedFields {
    const RAW_BYTE_LEN: usize = u16::RAW_BYTE_LEN
        + u8::RAW_BYTE_LEN
        + u8::RAW_BYTE_LEN
        + u8::RAW_BYTE_LEN
        + u8::RAW_BYTE_LEN;
}

/// The type 3 'kern' subtable.
#[derive(Debug, Clone, Copy)]
#[doc(hidden)]
pub struct Subtable3Marker {
    kern_value_byte_len: usize,
    left_class_byte_len: usize,
    right_class_byte_len: usize,
    kern_index_byte_len: usize,
}

impl Subtable3Marker {
    pub fn glyph_count_byte_range(&self) -> Range<usize> {
        let start = 0;
        start..start + u16::RAW_BYTE_LEN
    }

    pub fn kern_value_count_byte_range(&self) -> Range<usize> {
        let start = self.glyph_count_byte_range().end;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn left_class_count_byte_range(&self) -> Range<usize> {
        let start = self.kern_value_count_byte_range().end;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn right_class_count_byte_range(&self) -> Range<usize> {
        let start = self.left_class_count_byte_range().end;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn flags_byte_range(&self) -> Range<usize> {
        let start = self.right_class_count_byte_range().end;
        start..start + u8::RAW_BYTE_LEN
    }

    pub fn kern_value_byte_range(&self) -> Range<usize> {
        let start = self.flags_byte_range().end;
        start..start + self.kern_value_byte_len
    }

    pub fn left_class_byte_range(&self) -> Range<usize> {
        let start = self.kern_value_byte_range().end;
        start..start + self.left_class_byte_len
    }

    pub fn right_class_byte_range(&self) -> Range<usize> {
        let start = self.left_class_byte_range().end;
        start..start + self.right_class_byte_len
    }

    pub fn kern_index_byte_range(&self) -> Range<usize> {
        let start = self.right_class_byte_range().end;
        start..start + self.kern_index_byte_len
    }
}

impl MinByteRange for Subtable3Marker {
    fn min_byte_range(&self) -> Range<usize> {
        0..self.kern_index_byte_range().end
    }
}

impl<'a> FontRead<'a> for Subtable3<'a> {
    #[inline]
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        let mut cursor = data.cursor();
        let fixed_fields: &'a Subtable3FixedFields = cursor.read_ref()?;
        let glyph_count = fixed_fields.glyph_count.get();
        let kern_value_count = fixed_fields.kern_value_count;
        let left_class_count = fixed_fields.left_class_count;
        let right_class_count = fixed_fields.right_class_count;
        let kern_value_byte_len = (kern_value_count as usize)
            .checked_mul(i16::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(kern_value_byte_len);
        let left_class_byte_len = (glyph_count as usize)
            .checked_mul(u8::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(left_class_byte_len);
        let right_class_byte_len = (glyph_count as usize)
            .checked_mul(u8::RAW_BYTE_LEN)
            .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(right_class_byte_len);
        let kern_index_byte_len =
            (transforms::add_multiply(left_class_count, 0_usize, right_class_count))
                .checked_mul(u8::RAW_BYTE_LEN)
                .ok_or(ReadError::OutOfBounds)?;
        cursor.advance_by(kern_index_byte_len);
        cursor.finish(
            Subtable3Marker {
                kern_value_byte_len,
                left_class_byte_len,
                right_class_byte_len,
                kern_index_byte_len,
            },
            fixed_fields,
        )
    }
}

/// The type 3 'kern' subtable.
pub type Subtable3<'a> = TableRef<'a, Subtable3Marker, Subtable3FixedFields>;

#[allow(clippy::needless_lifetimes)]
impl<'a> Subtable3<'a> {
    /// The number of glyphs in this font.
    #[inline]
    pub fn glyph_count(&self) -> u16 {
        self.fixed_fields().glyph_count.get()
    }

    /// The number of kerning values.
    #[inline]
    pub fn kern_value_count(&self) -> u8 {
        self.fixed_fields().kern_value_count
    }

    /// The number of left-hand classes.
    #[inline]
    pub fn left_class_count(&self) -> u8 {
        self.fixed_fields().left_class_count
    }

    /// The number of right-hand classes.
    #[inline]
    pub fn right_class_count(&self) -> u8 {
        self.fixed_fields().right_class_count
    }

    /// Set to zero (reserved for future use).
    #[inline]
    pub fn flags(&self) -> u8 {
        self.fixed_fields().flags
    }

    /// The kerning values.
    #[inline]
    pub fn kern_value(&self) -> &'a [BigEndian<i16>] {
        let range = self.shape.kern_value_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// The left-hand classes.
    #[inline]
    pub fn left_class(&self) -> &'a [u8] {
        let range = self.shape.left_class_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// The right-hand classes.
    #[inline]
    pub fn right_class(&self) -> &'a [u8] {
        let range = self.shape.right_class_byte_range();
        self.data.read_array(range).unwrap()
    }

    /// The indices into the kernValue array.
    #[inline]
    pub fn kern_index(&self) -> &'a [u8] {
        let range = self.shape.kern_index_byte_range();
        self.data.read_array(range).unwrap()
    }
}

#[cfg(feature = "experimental_traverse")]
impl<'a> SomeTable<'a> for Subtable3<'a> {
    fn type_name(&self) -> &str {
        "Subtable3"
    }
    fn get_field(&self, idx: usize) -> Option<Field<'a>> {
        match idx {
            0usize => Some(Field::new("glyph_count", self.glyph_count())),
            1usize => Some(Field::new("kern_value_count", self.kern_value_count())),
            2usize => Some(Field::new("left_class_count", self.left_class_count())),
            3usize => Some(Field::new("right_class_count", self.right_class_count())),
            4usize => Some(Field::new("flags", self.flags())),
            5usize => Some(Field::new("kern_value", self.kern_value())),
            6usize => Some(Field::new("left_class", self.left_class())),
            7usize => Some(Field::new("right_class", self.right_class())),
            8usize => Some(Field::new("kern_index", self.kern_index())),
            _ => None,
        }
    }
}

#[cfg(feature = "experimental_traverse")]
#[allow(clippy::needless_lifetimes)]
impl<'a> std::fmt::Debug for Subtable3<'a> {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        (self as &dyn SomeTable<'a>).fmt(f)
    }
}
