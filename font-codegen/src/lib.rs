use std::collections::BTreeMap;

use quote::{quote, quote_spanned};
use syn::spanned::Spanned;

mod compile_types;
mod error;
mod parse;

pub use error::ErrorReport;

pub fn generate_code(code_str: &str) -> Result<String, syn::Error> {
    let parsed: parse::Items = syn::parse_str(code_str)?;

    let tables = codegen(&parsed)?;

    let source_str = rustfmt_wrapper::rustfmt(tables).unwrap();
    // convert doc comment attributes into normal doc comments
    let mod_comments = regex::Regex::new(r#"#!\[doc = "(.*)"\]"#).unwrap();
    let source_str = mod_comments.replace_all(&source_str, "//!$1");
    let doc_comments = regex::Regex::new(r#"#\[doc = "(.*)"\]"#).unwrap();
    let source_str = doc_comments.replace_all(&source_str, "///$1");
    let newlines_before_docs = regex::Regex::new(r#"([;\}])\n( *)(///|pub|impl|#)"#).unwrap();
    let source_str = newlines_before_docs.replace_all(&source_str, "$1\n\n$2$3");

    // add newlines after top-level items
    let re2 = regex::Regex::new(r"\n\}").unwrap();
    let source_str = re2.replace_all(&source_str, "\n}\n\n");
    let source_str = rustfmt_wrapper::rustfmt(source_str).unwrap();

    Ok(format!(
        "\
    // THIS FILE IS AUTOGENERATED.\n\
    // Any changes to this file will be overwritten.\n\
    // For more information about how codegen works, see font-codegen/README.md\n\n{}",
        source_str,
    ))
}

pub fn codegen(items: &parse::Items) -> Result<proc_macro2::TokenStream, syn::Error> {
    let mut code = Vec::new();
    for item in &items.items {
        let item_code = match item {
            parse::Item::Single(item) => generate_item_code(item),
            parse::Item::Group(group) => generate_group(group, &items.items)?,
            parse::Item::RawEnum(raw_enum) => generate_raw_enum(raw_enum),
            parse::Item::Flags(flags) => generate_flags(flags),
        };
        code.push(item_code);
    }

    let compile_mod = compile_types::generate_compile_module(items)?;
    let module_docs = &items.docs;
    let use_stmts = &items.use_stmts;
    let helpers = &items.helpers;
    Ok(quote! {
        #(#module_docs)*
        #(#use_stmts)*
        use font_types::*;
        #(#code)*
        #(#helpers)*

        #compile_mod
    })
}

fn generate_item_code(item: &parse::SingleItem) -> proc_macro2::TokenStream {
    if !item.has_references() {
        generate_zerocopy_impls(item)
    } else {
        generate_view_impls(item)
    }
}

fn generate_group(
    group: &parse::ItemGroup,
    all_items: &[parse::Item],
) -> Result<proc_macro2::TokenStream, syn::Error> {
    let name = &group.name;
    let lifetime = group.lifetime.as_ref().map(|_| quote!(<'a>));
    let docs = &group.docs;
    let shared_getter_impl = if group.generate_getters.is_some() {
        Some(generate_group_getter_impl(group, all_items)?)
    } else {
        None
    };

    let variants = group.variants.iter().map(|variant| {
        let name = &variant.name;
        let typ = &variant.typ;
        let docs = variant.docs.iter();
        let lifetime = variant.typ_lifetime.as_ref().map(|_| quote!(<'a>));
        quote! {
                #( #docs )*
                #name(#typ #lifetime)
        }
    });

    let format = &group.format_typ;
    let match_arms = group.variants.iter().map(|variant| {
        let name = &variant.name;
        let version = &variant.version;
        quote! {
            #version => {
                Some(Self::#name(font_types::FontRead::read(bytes)?))
            }
        }
    });

    let var_versions = group
        .variants
        .iter()
        .filter_map(|v| v.version.const_version_tokens());

    // ensure that constants passed in as versions actually exist, and that we
    // aren't just using them as bindings
    let validation_check = quote! {
        #( const _: #format = #var_versions; )*
    };
    let font_read = quote! {

        impl<'a> font_types::FontRead<'a> for #name #lifetime {
            fn read(bytes: &'a [u8]) -> Option<Self> {
                #validation_check
                let version: BigEndian<#format> = font_types::FontRead::read(bytes)?;
                match version.get() {
                    #( #match_arms ),*

                        _other => {
                            #[cfg(feature = "std")]
                            { eprintln!("unknown enum variant {:?}", version); }
                            None
                        }
                }
            }
        }
    };

    Ok(quote! {
        #( #docs )*
        pub enum #name #lifetime {
            #( #variants ),*
        }

        #font_read

        #shared_getter_impl
    })
}

fn generate_group_getter_impl(
    group: &parse::ItemGroup,
    all_items: &[parse::Item],
) -> Result<proc_macro2::TokenStream, syn::Error> {
    let items = group.variants.iter().map(|var|
        all_items
        .iter()
        .find_map(|item|  match item {
            parse::Item::Single(x) if x.name == var.typ => Some(x),
            _ => None,
        })
        .ok_or_else(|| syn::Error::new(var.typ.span(), "type not in scope (#[generate_getters] requires all items in same macro block)")))
        .collect::<Result<Vec<_>,_>>()?;

    let mut fields = BTreeMap::new();
    for item in &items {
        for field in item.fields.iter().filter(|fld| fld.visible()) {
            fields
                .entry(field.name())
                .or_insert_with(|| (field, Vec::new()))
                .1
                .push(&item.name);
        }
    }

    let match_left_sides = group
        .variants
        .iter()
        .map(|var| {
            let name = &var.name;
            let span = name.span();
            quote_spanned!(span=> Self::#name(_inner))
        })
        .collect::<Vec<_>>();

    let n_variants = group.variants.len();
    let mut getters = Vec::new();

    for (field, variants) in fields.values() {
        let field_name = field.name();
        let docs = field.docs();
        let (ret_type, match_right_sides) = if variants.len() == n_variants {
            let match_right_sides = (0..n_variants)
                .map(|_| quote!(_inner.#field_name()))
                .collect::<Vec<_>>();
            (field.getter_return_type(), match_right_sides)
        } else {
            let ret_type = field.getter_return_type();
            let ret_type = quote!(Option<#ret_type>);
            let match_right_sides = group
                .variants
                .iter()
                .map(|var| {
                    if variants.contains(&&var.typ) {
                        quote!( Some(_inner.#field_name()) )
                    } else {
                        quote!(None)
                    }
                })
                .collect();
            (ret_type, match_right_sides)
        };

        getters.push(quote! {
            #( #docs )*
            pub fn #field_name(&self) -> #ret_type {
                match self {
                    #( #match_left_sides => #match_right_sides, )*
                }
            }
        });
    }

    let name = &group.name;
    let lifetime = group.lifetime.as_ref().map(|_| quote!(<'a>));

    let offset_host_impl = if items.iter().all(|item| item.offset_host.is_some()) {
        Some(quote! {
            impl<'a> font_types::OffsetHost<'a> for #name #lifetime {
                fn bytes(&self) -> &'a [u8] {
                    match self {
                        #( #match_left_sides => _inner.bytes(), )*
                    }
                }
            }
        })
    } else {
        None
    };

    Ok(quote! {
        impl #lifetime #name #lifetime {
            #( #getters )*
        }

        #offset_host_impl
    })
}

fn generate_flags(raw: &parse::BitFlags) -> proc_macro2::TokenStream {
    let name = &raw.name;
    let docs = &raw.docs;
    let type_ = &raw.type_;
    let variants = raw.variants.iter().map(|variant| {
        let name = &variant.name;
        let value = &variant.value;
        let docs = &variant.docs;
        quote! {
            #( #docs )*
            const #name = #value;
        }
    });

    quote! {
        bitflags::bitflags! {
            #( #docs )*
            pub struct #name: #type_ {
                #( #variants )*
            }
        }

        impl font_types::Scalar for #name {
            type Raw = <#type_ as font_types::Scalar>::Raw;

            fn to_raw(self) -> Self::Raw {
                self.bits().to_raw()
            }

            fn from_raw(raw: Self::Raw) -> Self {
                let t = <#type_>::from_raw(raw);
                Self::from_bits_truncate(t)
            }
        }
    }
}

fn generate_raw_enum(raw: &parse::RawEnum) -> proc_macro2::TokenStream {
    let name = &raw.name;
    let docs = &raw.docs;
    let repr = &raw.repr;
    let variants = raw.variants.iter().map(|variant| {
        let name = &variant.name;
        let value = &variant.value;
        let docs = &variant.docs;
        quote! {
            #( #docs )*
            #name = #value,
        }
    });
    let variant_inits = raw.variants.iter().map(|variant| {
        let name = &variant.name;
        let value = &variant.value;
        quote!(#value => Self::#name,)
    });

    quote! {
        #( #docs )*
        #[derive(Clone, Copy, Debug, PartialEq, Eq)]
        #[repr(#repr)]
        pub enum #name {
            #( #variants )*
            Unknown,
        }

        impl #name {
            /// Create from a raw scalar.
            ///
            /// This will never fail; unknown values will be mapped to the `Unknown` variant
            pub fn new(raw: #repr) -> Self {
                match raw {
                    #( #variant_inits )*
                    _ => Self::Unknown,
                }
            }
        }
    }
}

fn generate_zerocopy_impls(item: &parse::SingleItem) -> proc_macro2::TokenStream {
    assert!(item.lifetime.is_none());
    let name = &item.name;
    let field_names = item
        .fields
        .iter()
        .map(|field| &field.as_single().unwrap().name);
    let docs = &item.docs;
    let field_types = item
        .fields
        .iter()
        .map(|field| field.as_single().unwrap().typ.view_field_tokens());
    let field_docs = item
        .fields
        .iter()
        .map(|fld| {
            let docs = &fld.as_single().unwrap().docs;
            quote!( #( #docs )* )
        })
        .collect::<Vec<_>>();

    let getters = item.fields.iter().map(parse::Field::view_getter_fn);

    quote! {
        #( #docs )*
        #[derive(Clone, Copy, Debug, zerocopy::FromBytes, zerocopy::Unaligned)]
        #[repr(C)]
        pub struct #name {
            #( #field_docs pub #field_names: #field_types, )*
        }

        impl #name {
            #(
                #getters
            )*
        }

    }
}

fn generate_view_impls(item: &parse::SingleItem) -> proc_macro2::TokenStream {
    let name = &item.name;
    let docs = &item.docs;

    // these are fields which are inputs to the size calculations of *other fields.
    // For each of these field, we generate a 'resolved' identifier, and we assign the
    // value of this field to that identifier at init time. Subsequent fields can then
    // access that identifier in their own generated code, to determine the runtime
    // value of something.
    #[allow(clippy::needless_collect)] // bad clippy
    let fields_used_as_inputs = item
        .fields
        .iter()
        .filter_map(parse::Field::as_array)
        .flat_map(|array| array.count.iter_input_fields())
        .collect::<Vec<_>>();

    // The fields in the declaration of the struct.
    let mut field_decls = Vec::new();
    // the getters for those fields that have getters
    let mut getters = Vec::new();
    // just the names; we use these at the end to assemble the struct (shorthand initializer syntax)
    let mut used_field_names = Vec::new();
    // the code to intiailize each field. each block of code is expected to take the form,
    // `let (field_name, bytes) = $expr`, where 'bytes' is the whatever is left over
    // from the input bytes after validating this field.
    let mut field_inits = Vec::new();

    for field in &item.fields {
        if matches!(field, parse::Field::Array(arr) if arr.variable_size.is_some()) {
            continue;
        }

        let name = field.name();
        let span = name.span();

        field_decls.push(field.view_field_decl());
        used_field_names.push(field.name().to_owned());

        if let Some(getter) = field.view_getter_fn() {
            getters.push(getter);
        }

        let field_init = field.view_init_expr();
        // if this field is used by another field, resolve it's current value
        let maybe_resolved_value = fields_used_as_inputs.contains(&name).then(|| {
            let resolved_ident = make_resolved_ident(name);
            let resolve_expr = field.resolve_expr();
            quote_spanned!(span=> let #resolved_ident = #resolve_expr;)
        });

        field_inits.push(quote! {
            #field_init
            #maybe_resolved_value
        });
    }

    let mut offset_host_impl = None;
    if let Some(attr) = item.offset_host.as_ref() {
        let span = attr.span();
        field_decls.push(quote_spanned!(span=> offset_bytes: &'a [u8]));
        used_field_names.push(syn::Ident::new("offset_bytes", span));
        // this needs to be the first item, otherwise offsets will be miscalculated,
        // since 'bytes' is consumed as we init items
        field_inits.insert(0, quote_spanned!(span=> let offset_bytes = bytes;));
        offset_host_impl = Some(quote_spanned! {span=>
            impl<'a> font_types::OffsetHost<'a> for #name<'a> {
                fn bytes(&self) -> &'a [u8] {
                    self.offset_bytes
                }
            }
        });
    }

    let init_body = quote! {
        #( #field_inits )*
        let _ = bytes;
        Some(#name {
            #( #used_field_names, )*
        })
    };

    let init_impl = if item.init.is_empty() {
        quote! {
            impl<'a> font_types::FontRead<'a> for #name<'a> {
                fn read(bytes: &'a [u8]) -> Option<Self> {
                    #init_body
                }
            }
        }
    } else {
        let init_args = item.init.iter().map(|arg| {
            let span = arg.span();
            quote_spanned!(span=> #arg: usize)
        });
        let init_aliases = item.init.iter().map(|arg| {
            let span = arg.span();
            let resolved = make_resolved_ident(arg);
            quote_spanned!(span=> let #resolved = #arg;)
        });

        quote! {
            impl<'a> #name<'a> {
                pub fn read(bytes: &'a [u8], #( #init_args ),* ) -> Option<Self> {
                    #( #init_aliases )*
                    #init_body
                }
            }
        }
    };

    quote! {
        #( #docs )*
        pub struct #name<'a> {
            #( #field_decls ),*
        }

        #init_impl
        impl<'a> #name<'a> {
            #( #getters )*
        }

        #offset_host_impl
    }
}

fn make_resolved_ident(ident: &syn::Ident) -> syn::Ident {
    quote::format_ident!("__resolved_{}", ident)
}
