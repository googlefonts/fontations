// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

pub use read_fonts::tables::varc::VarcFlags;

/// [VARC](https://github.com/harfbuzz/boring-expansion-spec/blob/main/VARC.md) (Variable Composites / Components Table)
///
/// [FontTools VARC](https://github.com/fonttools/fonttools/blob/5e6b12d12fa08abafbeb7570f47707fbedf69a45/Lib/fontTools/ttLib/tables/otData.py#L3459-L3476)
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Varc {
    pub coverage: OffsetMarker<CoverageTable, WIDTH_32>,
    pub multi_var_store: NullableOffsetMarker<MultiItemVariationStore, WIDTH_32>,
    pub condition_list: NullableOffsetMarker<ConditionList, WIDTH_32>,
    pub axis_indices_list: NullableOffsetMarker<Index2, WIDTH_32>,
    pub var_composite_glyphs: OffsetMarker<Index2, WIDTH_32>,
}

impl Varc {
    /// Construct a new `Varc`
    pub fn new(
        coverage: CoverageTable,
        multi_var_store: Option<MultiItemVariationStore>,
        condition_list: Option<ConditionList>,
        axis_indices_list: Option<Index2>,
        var_composite_glyphs: Index2,
    ) -> Self {
        Self {
            coverage: coverage.into(),
            multi_var_store: multi_var_store.into(),
            condition_list: condition_list.into(),
            axis_indices_list: axis_indices_list.into(),
            var_composite_glyphs: var_composite_glyphs.into(),
        }
    }
}

impl FontWrite for Varc {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        (MajorMinor::VERSION_1_0 as MajorMinor).write_into(writer);
        self.coverage.write_into(writer);
        self.multi_var_store.write_into(writer);
        self.condition_list.write_into(writer);
        self.axis_indices_list.write_into(writer);
        self.var_composite_glyphs.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::TopLevel(Varc::TAG)
    }
}

impl Validate for Varc {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Varc", |ctx| {
            ctx.in_field("coverage", |ctx| {
                self.coverage.validate_impl(ctx);
            });
            ctx.in_field("multi_var_store", |ctx| {
                self.multi_var_store.validate_impl(ctx);
            });
            ctx.in_field("condition_list", |ctx| {
                self.condition_list.validate_impl(ctx);
            });
            ctx.in_field("axis_indices_list", |ctx| {
                self.axis_indices_list.validate_impl(ctx);
            });
            ctx.in_field("var_composite_glyphs", |ctx| {
                self.var_composite_glyphs.validate_impl(ctx);
            });
        })
    }
}

impl TopLevelTable for Varc {
    const TAG: Tag = Tag::new(b"VARC");
}

impl<'a> FromObjRef<read_fonts::tables::varc::Varc<'a>> for Varc {
    fn from_obj_ref(obj: &read_fonts::tables::varc::Varc<'a>, _: FontData) -> Self {
        Varc {
            coverage: obj.coverage().to_owned_table(),
            multi_var_store: obj.multi_var_store().to_owned_table(),
            condition_list: obj.condition_list().to_owned_table(),
            axis_indices_list: obj.axis_indices_list().to_owned_table(),
            var_composite_glyphs: obj.var_composite_glyphs().to_owned_table(),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::varc::Varc<'a>> for Varc {}

impl<'a> FontRead<'a> for Varc {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::varc::Varc as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

/// * <https://github.com/fonttools/fonttools/blob/5e6b12d12fa08abafbeb7570f47707fbedf69a45/Lib/fontTools/ttLib/tables/otData.py#L3451-L3457>
/// * <https://github.com/harfbuzz/harfbuzz/blob/7be12b33e3f07067c159d8f516eb31df58c75876/src/hb-ot-layout-common.hh#L3517-L3520C3>
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MultiItemVariationStore {
    pub region_list: OffsetMarker<SparseVariationRegionList, WIDTH_32>,
    pub variation_data_count: u16,
    pub variation_data: Vec<OffsetMarker<MultiItemVariationData, WIDTH_32>>,
}

impl MultiItemVariationStore {
    /// Construct a new `MultiItemVariationStore`
    pub fn new(
        region_list: SparseVariationRegionList,
        variation_data_count: u16,
        variation_data: Vec<MultiItemVariationData>,
    ) -> Self {
        Self {
            region_list: region_list.into(),
            variation_data_count,
            variation_data: variation_data.into_iter().map(Into::into).collect(),
        }
    }
}

impl FontWrite for MultiItemVariationStore {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        (1 as u16).write_into(writer);
        self.region_list.write_into(writer);
        self.variation_data_count.write_into(writer);
        self.variation_data.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MultiItemVariationStore")
    }
}

impl Validate for MultiItemVariationStore {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("MultiItemVariationStore", |ctx| {
            ctx.in_field("region_list", |ctx| {
                self.region_list.validate_impl(ctx);
            });
            ctx.in_field("variation_data", |ctx| {
                if self.variation_data.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.variation_data.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::varc::MultiItemVariationStore<'a>>
    for MultiItemVariationStore
{
    fn from_obj_ref(
        obj: &read_fonts::tables::varc::MultiItemVariationStore<'a>,
        _: FontData,
    ) -> Self {
        MultiItemVariationStore {
            region_list: obj.region_list().to_owned_table(),
            variation_data_count: obj.variation_data_count(),
            variation_data: obj.variation_data().to_owned_table(),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::varc::MultiItemVariationStore<'a>>
    for MultiItemVariationStore
{
}

impl<'a> FontRead<'a> for MultiItemVariationStore {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::varc::MultiItemVariationStore as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SparseVariationRegionList {
    pub region_count: u16,
    pub regions: Vec<OffsetMarker<SparseVariationRegion, WIDTH_32>>,
}

impl SparseVariationRegionList {
    /// Construct a new `SparseVariationRegionList`
    pub fn new(region_count: u16, regions: Vec<SparseVariationRegion>) -> Self {
        Self {
            region_count,
            regions: regions.into_iter().map(Into::into).collect(),
        }
    }
}

impl FontWrite for SparseVariationRegionList {
    fn write_into(&self, writer: &mut TableWriter) {
        self.region_count.write_into(writer);
        self.regions.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("SparseVariationRegionList")
    }
}

impl Validate for SparseVariationRegionList {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("SparseVariationRegionList", |ctx| {
            ctx.in_field("regions", |ctx| {
                if self.regions.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.regions.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::varc::SparseVariationRegionList<'a>>
    for SparseVariationRegionList
{
    fn from_obj_ref(
        obj: &read_fonts::tables::varc::SparseVariationRegionList<'a>,
        _: FontData,
    ) -> Self {
        SparseVariationRegionList {
            region_count: obj.region_count(),
            regions: obj.regions().to_owned_table(),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::varc::SparseVariationRegionList<'a>>
    for SparseVariationRegionList
{
}

impl<'a> FontRead<'a> for SparseVariationRegionList {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::varc::SparseVariationRegionList as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SparseVariationRegion {
    pub region_axis_count: u16,
    pub region_axes: Vec<SparseRegionAxisCoordinates>,
}

impl SparseVariationRegion {
    /// Construct a new `SparseVariationRegion`
    pub fn new(region_axis_count: u16, region_axes: Vec<SparseRegionAxisCoordinates>) -> Self {
        Self {
            region_axis_count,
            region_axes,
        }
    }
}

impl FontWrite for SparseVariationRegion {
    fn write_into(&self, writer: &mut TableWriter) {
        self.region_axis_count.write_into(writer);
        self.region_axes.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("SparseVariationRegion")
    }
}

impl Validate for SparseVariationRegion {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("SparseVariationRegion", |ctx| {
            ctx.in_field("region_axes", |ctx| {
                if self.region_axes.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.region_axes.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::varc::SparseVariationRegion<'a>> for SparseVariationRegion {
    fn from_obj_ref(
        obj: &read_fonts::tables::varc::SparseVariationRegion<'a>,
        _: FontData,
    ) -> Self {
        let offset_data = obj.offset_data();
        SparseVariationRegion {
            region_axis_count: obj.region_axis_count(),
            region_axes: obj.region_axes().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::varc::SparseVariationRegion<'a>>
    for SparseVariationRegion
{
}

impl<'a> FontRead<'a> for SparseVariationRegion {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::varc::SparseVariationRegion as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SparseRegionAxisCoordinates {
    pub axis_index: u16,
    pub start: F2Dot14,
    pub peak: F2Dot14,
    pub end: F2Dot14,
}

impl SparseRegionAxisCoordinates {
    /// Construct a new `SparseRegionAxisCoordinates`
    pub fn new(axis_index: u16, start: F2Dot14, peak: F2Dot14, end: F2Dot14) -> Self {
        Self {
            axis_index,
            start,
            peak,
            end,
        }
    }
}

impl FontWrite for SparseRegionAxisCoordinates {
    fn write_into(&self, writer: &mut TableWriter) {
        self.axis_index.write_into(writer);
        self.start.write_into(writer);
        self.peak.write_into(writer);
        self.end.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("SparseRegionAxisCoordinates")
    }
}

impl Validate for SparseRegionAxisCoordinates {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl FromObjRef<read_fonts::tables::varc::SparseRegionAxisCoordinates>
    for SparseRegionAxisCoordinates
{
    fn from_obj_ref(
        obj: &read_fonts::tables::varc::SparseRegionAxisCoordinates,
        _: FontData,
    ) -> Self {
        SparseRegionAxisCoordinates {
            axis_index: obj.axis_index(),
            start: obj.start(),
            peak: obj.peak(),
            end: obj.end(),
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct MultiItemVariationData {
    pub region_index_count: u16,
    pub region_indices: Vec<u16>,
    pub delta_set_count: u32,
    pub delta_set_off_size: Option<u8>,
    pub delta_set_offsets: Option<Vec<u8>>,
    pub delta_set_data: Option<Vec<u8>>,
}

impl MultiItemVariationData {
    /// Construct a new `MultiItemVariationData`
    pub fn new(region_index_count: u16, region_indices: Vec<u16>, delta_set_count: u32) -> Self {
        Self {
            region_index_count,
            region_indices,
            delta_set_count,
            ..Default::default()
        }
    }
}

impl FontWrite for MultiItemVariationData {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        (1 as u8).write_into(writer);
        self.region_index_count.write_into(writer);
        self.region_indices.write_into(writer);
        self.delta_set_count.write_into(writer);
        (self.delta_set_count != 0).then(|| {
            self.delta_set_off_size
                .as_ref()
                .expect("missing conditional field should have failed validation")
                .write_into(writer)
        });
        (self.delta_set_count != 0).then(|| {
            self.delta_set_offsets
                .as_ref()
                .expect("missing conditional field should have failed validation")
                .write_into(writer)
        });
        (self.delta_set_count != 0).then(|| {
            self.delta_set_data
                .as_ref()
                .expect("missing conditional field should have failed validation")
                .write_into(writer)
        });
    }
    fn table_type(&self) -> TableType {
        TableType::Named("MultiItemVariationData")
    }
}

impl Validate for MultiItemVariationData {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("MultiItemVariationData", |ctx| {
            let delta_set_count = self.delta_set_count;
            ctx.in_field("region_indices", |ctx| {
                if self.region_indices.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
            });
            ctx.in_field("delta_set_off_size", |ctx| {
                if !(delta_set_count != 0) && self.delta_set_off_size.is_some() {
                    ctx.report("'delta_set_count' is zero but 'delta_set_off_size' is present")
                }
                if (delta_set_count != 0) && self.delta_set_off_size.is_none() {
                    ctx.report("'delta_set_count' is nonzero but 'delta_set_off_size' is None")
                }
            });
            ctx.in_field("delta_set_offsets", |ctx| {
                if !(delta_set_count != 0) && self.delta_set_offsets.is_some() {
                    ctx.report("'delta_set_count' is zero but 'delta_set_offsets' is present")
                }
                if (delta_set_count != 0) && self.delta_set_offsets.is_none() {
                    ctx.report("'delta_set_count' is nonzero but 'delta_set_offsets' is None")
                }
            });
            ctx.in_field("delta_set_data", |ctx| {
                if !(delta_set_count != 0) && self.delta_set_data.is_some() {
                    ctx.report("'delta_set_count' is zero but 'delta_set_data' is present")
                }
                if (delta_set_count != 0) && self.delta_set_data.is_none() {
                    ctx.report("'delta_set_count' is nonzero but 'delta_set_data' is None")
                }
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::varc::MultiItemVariationData<'a>>
    for MultiItemVariationData
{
    fn from_obj_ref(
        obj: &read_fonts::tables::varc::MultiItemVariationData<'a>,
        _: FontData,
    ) -> Self {
        let offset_data = obj.offset_data();
        MultiItemVariationData {
            region_index_count: obj.region_index_count(),
            region_indices: obj.region_indices().to_owned_obj(offset_data),
            delta_set_count: obj.delta_set_count(),
            delta_set_off_size: obj.delta_set_off_size(),
            delta_set_offsets: obj.delta_set_offsets().to_owned_obj(offset_data),
            delta_set_data: obj.delta_set_data().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::varc::MultiItemVariationData<'a>>
    for MultiItemVariationData
{
}

impl<'a> FontRead<'a> for MultiItemVariationData {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::varc::MultiItemVariationData as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct ConditionList {
    pub condition_count: u32,
    pub conditions: Vec<OffsetMarker<Condition, WIDTH_32>>,
}

impl ConditionList {
    /// Construct a new `ConditionList`
    pub fn new(condition_count: u32, conditions: Vec<Condition>) -> Self {
        Self {
            condition_count,
            conditions: conditions.into_iter().map(Into::into).collect(),
        }
    }
}

impl FontWrite for ConditionList {
    fn write_into(&self, writer: &mut TableWriter) {
        self.condition_count.write_into(writer);
        self.conditions.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("ConditionList")
    }
}

impl Validate for ConditionList {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("ConditionList", |ctx| {
            ctx.in_field("conditions", |ctx| {
                if self.conditions.len() > (u32::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.conditions.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::varc::ConditionList<'a>> for ConditionList {
    fn from_obj_ref(obj: &read_fonts::tables::varc::ConditionList<'a>, _: FontData) -> Self {
        ConditionList {
            condition_count: obj.condition_count(),
            conditions: obj.conditions().to_owned_table(),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::varc::ConditionList<'a>> for ConditionList {}

impl<'a> FontRead<'a> for ConditionList {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::varc::ConditionList as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

impl FontWrite for VarcFlags {
    fn write_into(&self, writer: &mut TableWriter) {
        writer.write_slice(&self.bits().to_be_bytes())
    }
}
