// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct BaseArray {
    /// Array of BaseRecords, in order of baseCoverage Index.
    pub base_records: Vec<BaseRecord>,
}

impl FontWrite for BaseArray {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        (u16::try_from(array_len(&self.base_records)).unwrap()).write_into(writer);
        self.base_records.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("BaseArray")
    }
}

impl Validate for BaseArray {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("BaseArray", |ctx| {
            ctx.in_field("base_records", |ctx| {
                if self.base_records.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.base_records.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::codegen_test::read_args::BaseArray<'a>> for BaseArray {
    fn from_obj_ref(obj: &read_fonts::codegen_test::read_args::BaseArray<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        BaseArray {
            base_records: obj
                .base_records()
                .iter()
                .filter_map(|x| x.map(|x| FromObjRef::from_obj_ref(&x, offset_data)).ok())
                .collect(),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::codegen_test::read_args::BaseArray<'a>> for BaseArray {}

/// Part of [BaseArray]
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct BaseRecord {
    /// Array of offsets (one per mark class) to Anchor tables. Offsets
    /// are from beginning of BaseArray table, ordered by class
    /// (offsets may be NULL).
    pub base_anchor_offsets: Vec<u16>,
}

impl FontWrite for BaseRecord {
    fn write_into(&self, writer: &mut TableWriter) {
        self.base_anchor_offsets.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("BaseRecord")
    }
}

impl Validate for BaseRecord {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("BaseRecord", |ctx| {
            ctx.in_field("base_anchor_offsets", |ctx| {
                if self.base_anchor_offsets.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
            });
        })
    }
}

impl FromObjRef<read_fonts::codegen_test::read_args::BaseRecord<'_>> for BaseRecord {
    fn from_obj_ref(
        obj: &read_fonts::codegen_test::read_args::BaseRecord,
        offset_data: FontData,
    ) -> Self {
        BaseRecord {
            base_anchor_offsets: obj.base_anchor_offsets().to_owned_obj(offset_data),
        }
    }
}
