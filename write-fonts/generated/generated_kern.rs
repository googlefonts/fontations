// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

pub use read_fonts::tables::kern::KernCoverage;

/// The [kern (Kerning)](https://docs.microsoft.com/en-us/typography/opentype/spec/kern) table
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Kern {
    pub subtables: Vec<Kern0>,
}

impl Kern {
    /// Construct a new `Kern`
    pub fn new(subtables: Vec<Kern0>) -> Self {
        Self { subtables }
    }
}

impl FontWrite for Kern {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        (0 as u16).write_into(writer);
        (u16::try_from(array_len(&self.subtables)).unwrap()).write_into(writer);
        self.subtables.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::TopLevel(Kern::TAG)
    }
}

impl Validate for Kern {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Kern", |ctx| {
            ctx.in_field("subtables", |ctx| {
                if self.subtables.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.subtables.validate_impl(ctx);
            });
        })
    }
}

impl TopLevelTable for Kern {
    const TAG: Tag = Tag::new(b"kern");
}

impl<'a> FromObjRef<read_fonts::tables::kern::Kern<'a>> for Kern {
    fn from_obj_ref(obj: &read_fonts::tables::kern::Kern<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        Kern {
            subtables: obj
                .subtables()
                .iter()
                .filter_map(|x| x.map(|x| FromObjRef::from_obj_ref(&x, offset_data)).ok())
                .collect(),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::kern::Kern<'a>> for Kern {}

impl<'a> FontRead<'a> for Kern {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::kern::Kern as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

impl FontWrite for KernCoverage {
    fn write_into(&self, writer: &mut TableWriter) {
        writer.write_slice(&self.bits().to_be_bytes())
    }
}

/// [kern Format 0](https://docs.microsoft.com/en-us/typography/opentype/spec/kern#format-0)
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Kern0 {
    /// What type of information is contained in this table.
    pub coverage: KernCoverage,
    /// The largest power of two less than or equal to the value of num_pairs, multiplied by the
    /// size in bytes of an entry in the table.
    pub search_range: u16,
    /// This is calculated as log2 of the largest power of two less than or equal to the value of num_pairs.
    /// This value indicates how many iterations of the search loop will have to be made.
    /// (For example, in a list of eight items, there would have to be three iterations of the loop).
    pub entry_selector: u16,
    /// The value of num_pairs minus the largest power of two less than or equal to num_pairs,
    /// and then multiplied by the size in bytes of an entry in the table.
    pub range_shift: u16,
    /// Kern pairs
    pub kerning_pairs: Vec<KernPair>,
}

impl Kern0 {
    /// Construct a new `Kern0`
    pub fn new(
        coverage: KernCoverage,
        search_range: u16,
        entry_selector: u16,
        range_shift: u16,
        kerning_pairs: Vec<KernPair>,
    ) -> Self {
        Self {
            coverage,
            search_range,
            entry_selector,
            range_shift,
            kerning_pairs,
        }
    }
}

impl FontWrite for Kern0 {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        (0 as u16).write_into(writer);
        (self.compute_length() as u16).write_into(writer);
        self.coverage.write_into(writer);
        (u16::try_from(array_len(&self.kerning_pairs)).unwrap()).write_into(writer);
        self.search_range.write_into(writer);
        self.entry_selector.write_into(writer);
        self.range_shift.write_into(writer);
        self.kerning_pairs.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("Kern0")
    }
}

impl Validate for Kern0 {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Kern0", |ctx| {
            ctx.in_field("kerning_pairs", |ctx| {
                if self.kerning_pairs.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.kerning_pairs.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::kern::Kern0<'a>> for Kern0 {
    fn from_obj_ref(obj: &read_fonts::tables::kern::Kern0<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        Kern0 {
            coverage: obj.coverage(),
            search_range: obj.search_range(),
            entry_selector: obj.entry_selector(),
            range_shift: obj.range_shift(),
            kerning_pairs: obj.kerning_pairs().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::kern::Kern0<'a>> for Kern0 {}

impl<'a> FontRead<'a> for Kern0 {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::kern::Kern0 as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct KernPair {
    /// The glyph index for the left-hand glyph in the kerning pair.
    pub left: u16,
    /// The glyph index for the right-hand glyph in the kerning pair.
    pub right: u16,
    /// The kerning value for the above pair, in font design units.
    /// If this value is greater than zero, the characters will be moved apart.
    /// If this value is less than zero, the character will be moved closer together.
    pub value: FWord,
}

impl KernPair {
    /// Construct a new `KernPair`
    pub fn new(left: u16, right: u16, value: FWord) -> Self {
        Self { left, right, value }
    }
}

impl FontWrite for KernPair {
    fn write_into(&self, writer: &mut TableWriter) {
        self.left.write_into(writer);
        self.right.write_into(writer);
        self.value.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("KernPair")
    }
}

impl Validate for KernPair {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl FromObjRef<read_fonts::tables::kern::KernPair> for KernPair {
    fn from_obj_ref(obj: &read_fonts::tables::kern::KernPair, _: FontData) -> Self {
        KernPair {
            left: obj.left(),
            right: obj.right(),
            value: obj.value(),
        }
    }
}
