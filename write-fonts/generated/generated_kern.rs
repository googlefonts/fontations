// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

/// The OpenType [kerning](https://learn.microsoft.com/en-us/typography/opentype/spec/kern) table.
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct OtKern {
    /// Number of subtables in the kerning table.
    pub n_tables: u16,
    /// Data for subtables, immediately following the header.
    pub subtable_data: Vec<u8>,
}

impl OtKern {
    /// Construct a new `OtKern`
    pub fn new(n_tables: u16, subtable_data: Vec<u8>) -> Self {
        Self {
            n_tables,
            subtable_data,
        }
    }
}

impl Validate for OtKern {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl<'a> FromObjRef<read_fonts::tables::kern::OtKern<'a>> for OtKern {
    fn from_obj_ref(obj: &read_fonts::tables::kern::OtKern<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        OtKern {
            n_tables: obj.n_tables(),
            subtable_data: obj.subtable_data().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::kern::OtKern<'a>> for OtKern {}

impl<'a> FontRead<'a> for OtKern {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::kern::OtKern as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

/// The Apple Advanced Typography [kerning](https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6kern.html) table.
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AatKern {
    /// The number of subtables included in the kerning table.
    pub n_tables: u32,
    /// Data for subtables, immediately following the header.    
    pub subtable_data: Vec<u8>,
}

impl AatKern {
    /// Construct a new `AatKern`
    pub fn new(n_tables: u32, subtable_data: Vec<u8>) -> Self {
        Self {
            n_tables,
            subtable_data,
        }
    }
}

impl Validate for AatKern {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl<'a> FromObjRef<read_fonts::tables::kern::AatKern<'a>> for AatKern {
    fn from_obj_ref(obj: &read_fonts::tables::kern::AatKern<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        AatKern {
            n_tables: obj.n_tables(),
            subtable_data: obj.subtable_data().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::kern::AatKern<'a>> for AatKern {}

impl<'a> FontRead<'a> for AatKern {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::kern::AatKern as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

/// A subtable in an OT `kern` table.
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct OtSubtable {
    /// Circumstances under which this table is used.
    pub coverage: u16,
    /// Subtable specific data.
    pub data: Vec<u8>,
}

impl OtSubtable {
    /// Construct a new `OtSubtable`
    pub fn new(coverage: u16, data: Vec<u8>) -> Self {
        Self { coverage, data }
    }
}

impl Validate for OtSubtable {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl<'a> FromObjRef<read_fonts::tables::kern::OtSubtable<'a>> for OtSubtable {
    fn from_obj_ref(obj: &read_fonts::tables::kern::OtSubtable<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        OtSubtable {
            coverage: obj.coverage(),
            data: obj.data().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::kern::OtSubtable<'a>> for OtSubtable {}

impl<'a> FontRead<'a> for OtSubtable {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::kern::OtSubtable as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

/// A subtable in an AAT `kern` table.
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AatSubtable {
    /// Circumstances under which this table is used.
    pub coverage: u16,
    /// The tuple index (used for variations fonts). This value specifies which tuple this subtable covers.
    pub tuple_index: u16,
    /// Subtable specific data.
    pub data: Vec<u8>,
}

impl AatSubtable {
    /// Construct a new `AatSubtable`
    pub fn new(coverage: u16, tuple_index: u16, data: Vec<u8>) -> Self {
        Self {
            coverage,
            tuple_index,
            data,
        }
    }
}

impl Validate for AatSubtable {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl<'a> FromObjRef<read_fonts::tables::kern::AatSubtable<'a>> for AatSubtable {
    fn from_obj_ref(obj: &read_fonts::tables::kern::AatSubtable<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        AatSubtable {
            coverage: obj.coverage(),
            tuple_index: obj.tuple_index(),
            data: obj.data().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::kern::AatSubtable<'a>> for AatSubtable {}

impl<'a> FontRead<'a> for AatSubtable {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::kern::AatSubtable as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

/// The type 0 `kern` subtable.
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Subtable0 {
    /// The largest power of two less than or equal to the value of nPairs, multiplied by the size in bytes of an entry in the subtable.
    pub search_range: u16,
    /// This is calculated as log2 of the largest power of two less than or equal to the value of nPairs. This value indicates how many iterations of the search loop have to be made. For example, in a list of eight items, there would be three iterations of the loop.
    pub entry_selector: u16,
    /// The value of nPairs minus the largest power of two less than or equal to nPairs. This is multiplied by the size in bytes of an entry in the table.
    pub range_shift: u16,
    /// Kerning records.
    pub pairs: Vec<Subtable0Pair>,
}

impl Subtable0 {
    /// Construct a new `Subtable0`
    pub fn new(
        search_range: u16,
        entry_selector: u16,
        range_shift: u16,
        pairs: Vec<Subtable0Pair>,
    ) -> Self {
        Self {
            search_range,
            entry_selector,
            range_shift,
            pairs,
        }
    }
}

impl FontWrite for Subtable0 {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        (u16::try_from(array_len(&self.pairs)).unwrap()).write_into(writer);
        self.search_range.write_into(writer);
        self.entry_selector.write_into(writer);
        self.range_shift.write_into(writer);
        self.pairs.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("Subtable0")
    }
}

impl Validate for Subtable0 {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Subtable0", |ctx| {
            ctx.in_field("pairs", |ctx| {
                if self.pairs.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.pairs.validate_impl(ctx);
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::kern::Subtable0<'a>> for Subtable0 {
    fn from_obj_ref(obj: &read_fonts::tables::kern::Subtable0<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        Subtable0 {
            search_range: obj.search_range(),
            entry_selector: obj.entry_selector(),
            range_shift: obj.range_shift(),
            pairs: obj.pairs().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::kern::Subtable0<'a>> for Subtable0 {}

impl<'a> FontRead<'a> for Subtable0 {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::kern::Subtable0 as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

/// The type 0 `kerx` subtable kerning record.
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Subtable0Pair {
    /// The glyph index for the lefthand glyph in the kerning pair.
    pub left: GlyphId16,
    /// The glyph index for the righthand glyph in the kerning pair.
    pub right: GlyphId16,
    /// Kerning value.
    pub value: i16,
}

impl Subtable0Pair {
    /// Construct a new `Subtable0Pair`
    pub fn new(left: GlyphId16, right: GlyphId16, value: i16) -> Self {
        Self { left, right, value }
    }
}

impl FontWrite for Subtable0Pair {
    fn write_into(&self, writer: &mut TableWriter) {
        self.left.write_into(writer);
        self.right.write_into(writer);
        self.value.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("Subtable0Pair")
    }
}

impl Validate for Subtable0Pair {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl FromObjRef<read_fonts::tables::kern::Subtable0Pair> for Subtable0Pair {
    fn from_obj_ref(obj: &read_fonts::tables::kern::Subtable0Pair, _: FontData) -> Self {
        Subtable0Pair {
            left: obj.left(),
            right: obj.right(),
            value: obj.value(),
        }
    }
}

/// Class table for the type 2 `kern` subtable.
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Subtable2ClassTable {
    /// First glyph in class range.
    pub first_glyph: GlyphId16,
    /// Number of glyph in class range.
    pub n_glyphs: u16,
    /// The offsets array for all of the glyphs in the range.
    pub offsets: Vec<u16>,
}

impl Subtable2ClassTable {
    /// Construct a new `Subtable2ClassTable`
    pub fn new(first_glyph: GlyphId16, n_glyphs: u16, offsets: Vec<u16>) -> Self {
        Self {
            first_glyph,
            n_glyphs,
            offsets,
        }
    }
}

impl FontWrite for Subtable2ClassTable {
    fn write_into(&self, writer: &mut TableWriter) {
        self.first_glyph.write_into(writer);
        self.n_glyphs.write_into(writer);
        self.offsets.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("Subtable2ClassTable")
    }
}

impl Validate for Subtable2ClassTable {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Subtable2ClassTable", |ctx| {
            ctx.in_field("offsets", |ctx| {
                if self.offsets.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::kern::Subtable2ClassTable<'a>> for Subtable2ClassTable {
    fn from_obj_ref(obj: &read_fonts::tables::kern::Subtable2ClassTable<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        Subtable2ClassTable {
            first_glyph: obj.first_glyph(),
            n_glyphs: obj.n_glyphs(),
            offsets: obj.offsets().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::kern::Subtable2ClassTable<'a>> for Subtable2ClassTable {}

impl<'a> FontRead<'a> for Subtable2ClassTable {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::kern::Subtable2ClassTable as FontRead>::read(data)
            .map(|x| x.to_owned_table())
    }
}

/// The type 3 'kern' subtable.
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Subtable3 {
    /// The number of glyphs in this font.
    pub glyph_count: u16,
    /// The number of left-hand classes.
    pub left_class_count: u8,
    /// The number of right-hand classes.
    pub right_class_count: u8,
    /// The kerning values.
    pub kern_value: Vec<i16>,
    /// The left-hand classes.
    pub left_class: Vec<u8>,
    /// The right-hand classes.
    pub right_class: Vec<u8>,
    /// The indices into the kernValue array.
    pub kern_index: Vec<u8>,
}

impl Subtable3 {
    /// Construct a new `Subtable3`
    pub fn new(
        glyph_count: u16,
        left_class_count: u8,
        right_class_count: u8,
        kern_value: Vec<i16>,
        left_class: Vec<u8>,
        right_class: Vec<u8>,
        kern_index: Vec<u8>,
    ) -> Self {
        Self {
            glyph_count,
            left_class_count,
            right_class_count,
            kern_value,
            left_class,
            right_class,
            kern_index,
        }
    }
}

impl FontWrite for Subtable3 {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        self.glyph_count.write_into(writer);
        (u8::try_from(array_len(&self.kern_value)).unwrap()).write_into(writer);
        self.left_class_count.write_into(writer);
        self.right_class_count.write_into(writer);
        (0 as u8).write_into(writer);
        self.kern_value.write_into(writer);
        self.left_class.write_into(writer);
        self.right_class.write_into(writer);
        self.kern_index.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("Subtable3")
    }
}

impl Validate for Subtable3 {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Subtable3", |ctx| {
            ctx.in_field("kern_value", |ctx| {
                if self.kern_value.len() > (u8::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
            });
            ctx.in_field("left_class", |ctx| {
                if self.left_class.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
            });
            ctx.in_field("right_class", |ctx| {
                if self.right_class.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
            });
        })
    }
}

impl<'a> FromObjRef<read_fonts::tables::kern::Subtable3<'a>> for Subtable3 {
    fn from_obj_ref(obj: &read_fonts::tables::kern::Subtable3<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        Subtable3 {
            glyph_count: obj.glyph_count(),
            left_class_count: obj.left_class_count(),
            right_class_count: obj.right_class_count(),
            kern_value: obj.kern_value().to_owned_obj(offset_data),
            left_class: obj.left_class().to_owned_obj(offset_data),
            right_class: obj.right_class().to_owned_obj(offset_data),
            kern_index: obj.kern_index().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::kern::Subtable3<'a>> for Subtable3 {}

impl<'a> FontRead<'a> for Subtable3 {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::kern::Subtable3 as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}
