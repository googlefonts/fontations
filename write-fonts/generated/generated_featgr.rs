// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

pub use read_fonts::tables::featgr::FeatureFlags;

/// The graphite feature table - this is similar but not identical to apple's feature table.
#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Feat {
    pub features: Vec<Feature>,
}

impl Feat {
    /// Construct a new `Feat`
    pub fn new(features: Vec<Feature>) -> Self {
        Self { features }
    }
}

impl FontWrite for Feat {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        let version = self.compute_version() as MajorMinor;
        version.write_into(writer);
        (u16::try_from(array_len(&self.features)).unwrap()).write_into(writer);
        (0 as u16).write_into(writer);
        (0 as u32).write_into(writer);
        self.features.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::TopLevel(Feat::TAG)
    }
}

impl Validate for Feat {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Feat", |ctx| {
            ctx.in_field("features", |ctx| {
                if self.features.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.features.validate_impl(ctx);
            });
        })
    }
}

impl TopLevelTable for Feat {
    const TAG: Tag = Tag::new(b"Feat");
}

impl<'a> FromObjRef<read_fonts::tables::featgr::Feat<'a>> for Feat {
    fn from_obj_ref(obj: &read_fonts::tables::featgr::Feat<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        Feat {
            features: obj.features().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::featgr::Feat<'a>> for Feat {}

impl<'a> FontRead<'a> for Feat {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::featgr::Feat as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Feature {
    pub feat_id: Option<u32>,
    pub feat_id: Option<u16>,
    pub settings: OffsetMarker<Vec<Setting>, WIDTH_32>,
    pub flags: FeatureFlags,
    pub name_idx: NameId,
}

impl Feature {
    /// Construct a new `Feature`
    pub fn new(settings: Vec<Setting>, flags: FeatureFlags, name_idx: NameId) -> Self {
        Self {
            settings: settings.into(),
            flags,
            name_idx,
            ..Default::default()
        }
    }
}

impl FontWrite for Feature {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        version.compatible(3u16).then(|| {
            self.feat_id
                .as_ref()
                .expect("missing conditional field should have failed validation")
                .write_into(writer)
        });
        !version.compatible(3u16).then(|| {
            self.feat_id
                .as_ref()
                .expect("missing conditional field should have failed validation")
                .write_into(writer)
        });
        (u16::try_from(array_len(&self.settings)).unwrap()).write_into(writer);
        version
            .compatible(2u16)
            .then(|| (0 as u16).write_into(writer));
        self.settings.write_into(writer);
        self.flags.write_into(writer);
        self.name_idx.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("Feature")
    }
}

impl Validate for Feature {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Feature", |ctx| {
            ctx.in_field("feat_id", |ctx| {
                if version.compatible(3u16) && self.feat_id.is_none() {
                    ctx.report(format!("field must be present for version {version}"));
                }
            });
            ctx.in_field("feat_id", |ctx| {
                if !version.compatible(3u16) && self.feat_id.is_none() {
                    ctx.report(format!("field must be present for version {version}"));
                }
            });
            ctx.in_field("settings", |ctx| {
                self.settings.validate_impl(ctx);
            });
        })
    }
}

impl FromObjRef<read_fonts::tables::featgr::Feature> for Feature {
    fn from_obj_ref(obj: &read_fonts::tables::featgr::Feature, offset_data: FontData) -> Self {
        Feature {
            feat_id: obj.feat_id(),
            feat_id: obj.feat_id(),
            settings: obj.settings(offset_data).to_owned_obj(offset_data),
            flags: obj.flags(),
            name_idx: obj.name_idx(),
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Setting {
    pub feature_id: u32,
    pub value: u16,
}

impl Setting {
    /// Construct a new `Setting`
    pub fn new(feature_id: u32, value: u16) -> Self {
        Self { feature_id, value }
    }
}

impl FontWrite for Setting {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        self.feature_id.write_into(writer);
        self.value.write_into(writer);
        (0 as u16).write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("Setting")
    }
}

impl Validate for Setting {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl FromObjRef<read_fonts::tables::featgr::Setting> for Setting {
    fn from_obj_ref(obj: &read_fonts::tables::featgr::Setting, _: FontData) -> Self {
        Setting {
            feature_id: obj.feature_id(),
            value: obj.value(),
        }
    }
}

impl FontWrite for FeatureFlags {
    fn write_into(&self, writer: &mut TableWriter) {
        writer.write_slice(&self.bits().to_be_bytes())
    }
}
