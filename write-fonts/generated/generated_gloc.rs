// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

pub use read_fonts::tables::gloc::GlocFlags;

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Gloc {
    pub flags: GlocFlags,
    pub num_attrs: u16,
    pub offsets: Option<Vec<u32>>,
    pub offsets: Option<Vec<u16>>,
}

impl Gloc {
    /// Construct a new `Gloc`
    pub fn new(flags: GlocFlags, num_attrs: u16) -> Self {
        Self {
            flags,
            num_attrs,
            ..Default::default()
        }
    }
}

impl FontWrite for Gloc {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        let version = self.compute_version() as MajorMinor;
        version.write_into(writer);
        self.flags.write_into(writer);
        self.num_attrs.write_into(writer);
        self.flags.contains(GlocFlags::NEED_LONG_FORMAT).then(|| {
            self.offsets
                .as_ref()
                .expect("missing conditional field should have failed validation")
                .write_into(writer)
        });
        !self.flags.intersects(GlocFlags::NEED_LONG_FORMAT).then(|| {
            self.offsets
                .as_ref()
                .expect("missing conditional field should have failed validation")
                .write_into(writer)
        });
    }
    fn table_type(&self) -> TableType {
        TableType::TopLevel(Gloc::TAG)
    }
}

impl Validate for Gloc {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Gloc", |ctx| {
            let version: MajorMinor = self.compute_version();
            let flags = self.flags;
            ctx.in_field("offsets", |ctx| {
                if !(flags.contains(GlocFlags::NEED_LONG_FORMAT)) && self.offsets.is_some() {
                    ctx.report("'offsets' is present but NEED_LONG_FORMAT not set")
                }
                if (flags.contains(GlocFlags::NEED_LONG_FORMAT)) && self.offsets.is_none() {
                    ctx.report("NEED_LONG_FORMAT is set but 'offsets' is None")
                }
            });
            ctx.in_field("offsets", |ctx| {
                if !(!flags.intersects(GlocFlags::NEED_LONG_FORMAT)) && self.offsets.is_some() {
                    ctx.report("if_cond is not satisfied but 'offsets' is not present.");
                }
                if (!flags.intersects(GlocFlags::NEED_LONG_FORMAT)) && self.offsets.is_none() {
                    ctx.report("if_cond is satisfied by 'offsets' is present.");
                }
            });
        })
    }
}

impl TopLevelTable for Gloc {
    const TAG: Tag = Tag::new(b"Gloc");
}

impl<'a> FromObjRef<read_fonts::tables::gloc::Gloc<'a>> for Gloc {
    fn from_obj_ref(obj: &read_fonts::tables::gloc::Gloc<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        Gloc {
            flags: obj.flags(),
            num_attrs: obj.num_attrs(),
            offsets: obj.offsets().to_owned_obj(offset_data),
            offsets: obj.offsets().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::gloc::Gloc<'a>> for Gloc {}

impl<'a> FontRead<'a> for Gloc {
    fn read(data: FontData<'a>) -> Result<Self, ReadError> {
        <read_fonts::tables::gloc::Gloc as FontRead>::read(data).map(|x| x.to_owned_table())
    }
}

impl FontWrite for GlocFlags {
    fn write_into(&self, writer: &mut TableWriter) {
        writer.write_slice(&self.bits().to_be_bytes())
    }
}
