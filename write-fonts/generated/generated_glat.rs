// THIS FILE IS AUTOGENERATED.
// Any changes to this file will be overwritten.
// For more information about how codegen works, see font-codegen/README.md

#[allow(unused_imports)]
use crate::codegen_prelude::*;

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct Glat {
    pub octaboxes: Vec<OctaBox>,
    pub glyphs: Vec<GlyphAttrRun>,
}

impl Glat {
    /// Construct a new `Glat`
    pub fn new(octaboxes: Vec<OctaBox>, glyphs: Vec<GlyphAttrRun>) -> Self {
        Self {
            octaboxes,
            glyphs,
            ..Default::default()
        }
    }
}

impl FontWrite for Glat {
    #[allow(clippy::unnecessary_cast)]
    fn write_into(&self, writer: &mut TableWriter) {
        let version = self.compute_version() as MajorMinor;
        version.write_into(writer);
        version
            .compatible((3u16, 0u16))
            .then(|| (1 as u32).write_into(writer));
        self.octaboxes.write_into(writer);
        self.glyphs.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::TopLevel(Glat::TAG)
    }
}

impl Validate for Glat {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("Glat", |ctx| {
            let version: MajorMinor = self.compute_version();
            ctx.in_field("octaboxes", |ctx| {
                if self.octaboxes.len() > (u16::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
                self.octaboxes.validate_impl(ctx);
            });
            ctx.in_field("glyphs", |ctx| {
                self.glyphs.validate_impl(ctx);
            });
        })
    }
}

impl TopLevelTable for Glat {
    const TAG: Tag = Tag::new(b"Glat");
}

impl<'a> FromObjRef<read_fonts::tables::glat::Glat<'a>> for Glat {
    fn from_obj_ref(obj: &read_fonts::tables::glat::Glat<'a>, _: FontData) -> Self {
        let offset_data = obj.offset_data();
        Glat {
            octaboxes: obj.octaboxes().to_owned_obj(offset_data),
            glyphs: obj.glyphs().to_owned_obj(offset_data),
        }
    }
}

#[allow(clippy::needless_lifetimes)]
impl<'a> FromTableRef<read_fonts::tables::glat::Glat<'a>> for Glat {}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct OctaBox {
    pub bitmap: u16,
    pub dn_min: u8,
    pub dn_max: u8,
    pub dp_min: u8,
    pub dp_max: u8,
    pub sub_box: Vec<SubBox>,
}

impl OctaBox {
    /// Construct a new `OctaBox`
    pub fn new(
        bitmap: u16,
        dn_min: u8,
        dn_max: u8,
        dp_min: u8,
        dp_max: u8,
        sub_box: Vec<SubBox>,
    ) -> Self {
        Self {
            bitmap,
            dn_min,
            dn_max,
            dp_min,
            dp_max,
            sub_box,
        }
    }
}

impl FontWrite for OctaBox {
    fn write_into(&self, writer: &mut TableWriter) {
        self.bitmap.write_into(writer);
        self.dn_min.write_into(writer);
        self.dn_max.write_into(writer);
        self.dp_min.write_into(writer);
        self.dp_max.write_into(writer);
        self.sub_box.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("OctaBox")
    }
}

impl Validate for OctaBox {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("OctaBox", |ctx| {
            ctx.in_field("sub_box", |ctx| {
                self.sub_box.validate_impl(ctx);
            });
        })
    }
}

impl FromObjRef<read_fonts::tables::glat::OctaBox<'_>> for OctaBox {
    fn from_obj_ref(obj: &read_fonts::tables::glat::OctaBox, offset_data: FontData) -> Self {
        OctaBox {
            bitmap: obj.bitmap(),
            dn_min: obj.dn_min(),
            dn_max: obj.dn_max(),
            dp_min: obj.dp_min(),
            dp_max: obj.dp_max(),
            sub_box: obj.sub_box().to_owned_obj(offset_data),
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct GlyphAttrRun {
    pub start: Option<u8>,
    pub length: Option<u8>,
    pub start: Option<u16>,
    pub length: Option<u16>,
    pub attrs: Vec<u16>,
}

impl GlyphAttrRun {
    /// Construct a new `GlyphAttrRun`
    pub fn new(attrs: Vec<u16>) -> Self {
        Self {
            attrs,
            ..Default::default()
        }
    }
}

impl FontWrite for GlyphAttrRun {
    fn write_into(&self, writer: &mut TableWriter) {
        !version.compatible(2u16).then(|| {
            self.start
                .as_ref()
                .expect("missing conditional field should have failed validation")
                .write_into(writer)
        });
        !version.compatible(2u16).then(|| {
            self.length
                .as_ref()
                .expect("missing conditional field should have failed validation")
                .write_into(writer)
        });
        version.compatible(2u16).then(|| {
            self.start
                .as_ref()
                .expect("missing conditional field should have failed validation")
                .write_into(writer)
        });
        version.compatible(2u16).then(|| {
            self.length
                .as_ref()
                .expect("missing conditional field should have failed validation")
                .write_into(writer)
        });
        self.attrs.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("GlyphAttrRun")
    }
}

impl Validate for GlyphAttrRun {
    fn validate_impl(&self, ctx: &mut ValidationCtx) {
        ctx.in_table("GlyphAttrRun", |ctx| {
            ctx.in_field("start", |ctx| {
                if !version.compatible(2u16) && self.start.is_none() {
                    ctx.report(format!("field must be present for version {version}"));
                }
            });
            ctx.in_field("length", |ctx| {
                if !version.compatible(2u16) && self.length.is_none() {
                    ctx.report(format!("field must be present for version {version}"));
                }
            });
            ctx.in_field("start", |ctx| {
                if version.compatible(2u16) && self.start.is_none() {
                    ctx.report(format!("field must be present for version {version}"));
                }
            });
            ctx.in_field("length", |ctx| {
                if version.compatible(2u16) && self.length.is_none() {
                    ctx.report(format!("field must be present for version {version}"));
                }
            });
            ctx.in_field("attrs", |ctx| {
                if self.attrs.len() > (u8::MAX as usize) {
                    ctx.report("array exceeds max length");
                }
            });
        })
    }
}

impl FromObjRef<read_fonts::tables::glat::GlyphAttrRun<'_>> for GlyphAttrRun {
    fn from_obj_ref(obj: &read_fonts::tables::glat::GlyphAttrRun, offset_data: FontData) -> Self {
        GlyphAttrRun {
            start: obj.start(),
            length: obj.length(),
            start: obj.start(),
            length: obj.length(),
            attrs: obj.attrs().to_owned_obj(offset_data),
        }
    }
}

#[derive(Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct SubBox {
    pub left: u8,
    pub right: u8,
    pub bottom: u8,
    pub top: u8,
    pub dn_min: u8,
    pub dn_max: u8,
    pub dp_min: u8,
    pub dp_max: u8,
}

impl SubBox {
    /// Construct a new `SubBox`
    #[allow(clippy::too_many_arguments)]
    pub fn new(
        left: u8,
        right: u8,
        bottom: u8,
        top: u8,
        dn_min: u8,
        dn_max: u8,
        dp_min: u8,
        dp_max: u8,
    ) -> Self {
        Self {
            left,
            right,
            bottom,
            top,
            dn_min,
            dn_max,
            dp_min,
            dp_max,
        }
    }
}

impl FontWrite for SubBox {
    fn write_into(&self, writer: &mut TableWriter) {
        self.left.write_into(writer);
        self.right.write_into(writer);
        self.bottom.write_into(writer);
        self.top.write_into(writer);
        self.dn_min.write_into(writer);
        self.dn_max.write_into(writer);
        self.dp_min.write_into(writer);
        self.dp_max.write_into(writer);
    }
    fn table_type(&self) -> TableType {
        TableType::Named("SubBox")
    }
}

impl Validate for SubBox {
    fn validate_impl(&self, _ctx: &mut ValidationCtx) {}
}

impl FromObjRef<read_fonts::tables::glat::SubBox> for SubBox {
    fn from_obj_ref(obj: &read_fonts::tables::glat::SubBox, _: FontData) -> Self {
        SubBox {
            left: obj.left(),
            right: obj.right(),
            bottom: obj.bottom(),
            top: obj.top(),
            dn_min: obj.dn_min(),
            dn_max: obj.dn_max(),
            dp_min: obj.dp_min(),
            dp_max: obj.dp_max(),
        }
    }
}
